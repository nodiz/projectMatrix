
AVRASM ver. 2.2.7  C:\Users\Gauzelin\Documents\Atmel Studio\7.0\projectMatrix\projectMatrix\main.asm Wed May 30 01:42:32 2018

[builtin](2): Including file 'C:/Program Files (x86)\Atmel\Studio\7.0\Packs\atmel\ATmega_DFP\1.2.150\avrasm\inc\m128def.inc'
C:\Users\Gauzelin\Documents\Atmel Studio\7.0\projectMatrix\projectMatrix\main.asm(7): Including file 'C:\Users\Gauzelin\Documents\Atmel Studio\7.0\projectMatrix\projectMatrix\macros.asm'
C:\Users\Gauzelin\Documents\Atmel Studio\7.0\projectMatrix\projectMatrix\main.asm(8): Including file 'C:\Users\Gauzelin\Documents\Atmel Studio\7.0\projectMatrix\projectMatrix\definitions.asm'
C:\Users\Gauzelin\Documents\Atmel Studio\7.0\projectMatrix\projectMatrix\main.asm(131): Including file 'C:\Users\Gauzelin\Documents\Atmel Studio\7.0\projectMatrix\projectMatrix\encoder.asm'
C:\Users\Gauzelin\Documents\Atmel Studio\7.0\projectMatrix\projectMatrix\main.asm(132): Including file 'C:\Users\Gauzelin\Documents\Atmel Studio\7.0\projectMatrix\projectMatrix\lcd.asm'
C:\Users\Gauzelin\Documents\Atmel Studio\7.0\projectMatrix\projectMatrix\main.asm(133): Including file 'C:\Users\Gauzelin\Documents\Atmel Studio\7.0\projectMatrix\projectMatrix\printf.asm'
C:\Users\Gauzelin\Documents\Atmel Studio\7.0\projectMatrix\projectMatrix\main.asm(134): Including file 'C:\Users\Gauzelin\Documents\Atmel Studio\7.0\projectMatrix\projectMatrix\sound.asm'
C:\Users\Gauzelin\Documents\Atmel Studio\7.0\projectMatrix\projectMatrix\main.asm(135): Including file 'C:\Users\Gauzelin\Documents\Atmel Studio\7.0\projectMatrix\projectMatrix\avrLED.asm'
C:\Users\Gauzelin\Documents\Atmel Studio\7.0\projectMatrix\projectMatrix\main.asm(136): Including file 'C:\Users\Gauzelin\Documents\Atmel Studio\7.0\projectMatrix\projectMatrix\animation.asm'
C:\Users\Gauzelin\Documents\Atmel Studio\7.0\projectMatrix\projectMatrix\main.asm(137): Including file 'C:\Users\Gauzelin\Documents\Atmel Studio\7.0\projectMatrix\projectMatrix\jeu.asm'
C:\Users\Gauzelin\Documents\Atmel Studio\7.0\projectMatrix\projectMatrix\main.asm(138): Including file 'C:\Users\Gauzelin\Documents\Atmel Studio\7.0\projectMatrix\projectMatrix\spectro.asm'
C:\Users\Gauzelin\Documents\Atmel Studio\7.0\projectMatrix\projectMatrix\main.asm(139): Including file 'C:\Users\Gauzelin\Documents\Atmel Studio\7.0\projectMatrix\projectMatrix\message.asm'
[builtin](2): Including file 'C:/Program Files (x86)\Atmel\Studio\7.0\Packs\atmel\ATmega_DFP\1.2.150\avrasm\inc\m128def.inc'
C:\Users\Gauzelin\Documents\Atmel Studio\7.0\projectMatrix\projectMatrix\main.asm(7): Including file 'C:\Users\Gauzelin\Documents\Atmel Studio\7.0\projectMatrix\projectMatrix\macros.asm'
C:\Users\Gauzelin\Documents\Atmel Studio\7.0\projectMatrix\projectMatrix\main.asm(8): Including file 'C:\Users\Gauzelin\Documents\Atmel Studio\7.0\projectMatrix\projectMatrix\definitions.asm'
C:\Users\Gauzelin\Documents\Atmel Studio\7.0\projectMatrix\projectMatrix\main.asm(131): Including file 'C:\Users\Gauzelin\Documents\Atmel Studio\7.0\projectMatrix\projectMatrix\encoder.asm'
C:\Users\Gauzelin\Documents\Atmel Studio\7.0\projectMatrix\projectMatrix\main.asm(132): Including file 'C:\Users\Gauzelin\Documents\Atmel Studio\7.0\projectMatrix\projectMatrix\lcd.asm'
C:\Users\Gauzelin\Documents\Atmel Studio\7.0\projectMatrix\projectMatrix\main.asm(133): Including file 'C:\Users\Gauzelin\Documents\Atmel Studio\7.0\projectMatrix\projectMatrix\printf.asm'
C:\Users\Gauzelin\Documents\Atmel Studio\7.0\projectMatrix\projectMatrix\main.asm(134): Including file 'C:\Users\Gauzelin\Documents\Atmel Studio\7.0\projectMatrix\projectMatrix\sound.asm'
C:\Users\Gauzelin\Documents\Atmel Studio\7.0\projectMatrix\projectMatrix\main.asm(135): Including file 'C:\Users\Gauzelin\Documents\Atmel Studio\7.0\projectMatrix\projectMatrix\avrLED.asm'
C:\Users\Gauzelin\Documents\Atmel Studio\7.0\projectMatrix\projectMatrix\main.asm(136): Including file 'C:\Users\Gauzelin\Documents\Atmel Studio\7.0\projectMatrix\projectMatrix\animation.asm'
C:\Users\Gauzelin\Documents\Atmel Studio\7.0\projectMatrix\projectMatrix\main.asm(137): Including file 'C:\Users\Gauzelin\Documents\Atmel Studio\7.0\projectMatrix\projectMatrix\jeu.asm'
C:\Users\Gauzelin\Documents\Atmel Studio\7.0\projectMatrix\projectMatrix\main.asm(138): Including file 'C:\Users\Gauzelin\Documents\Atmel Studio\7.0\projectMatrix\projectMatrix\spectro.asm'
C:\Users\Gauzelin\Documents\Atmel Studio\7.0\projectMatrix\projectMatrix\main.asm(139): Including file 'C:\Users\Gauzelin\Documents\Atmel Studio\7.0\projectMatrix\projectMatrix\message.asm'
                                 
                                 ;
                                 
                                 ;***** Created: 2011-02-09 12:03 ******* Source: ATmega128.xml ***********
                                 ;*************************************************************************
                                 ;* A P P L I C A T I O N   N O T E   F O R   T H E   A V R   F A M I L Y
                                 ;* 
                                 ;* Number            : AVR000
                                 ;* File Name         : "m128def.inc"
                                 ;* Title             : Register/Bit Definitions for the ATmega128
                                 ;* Date              : 2011-02-09
                                 ;* Version           : 2.35
                                 ;* Support E-mail    : avr@atmel.com
                                 ;* Target MCU        : ATmega128
                                 ;* 
                                 ;* DESCRIPTION
                                 ;* When including this file in the assembly program file, all I/O register 
                                 ;* names and I/O register bit names appearing in the data book can be used.
                                 ;* In addition, the six registers forming the three data pointers X, Y and 
                                 ;* Z have been assigned names XL - ZH. Highest RAM address for Internal 
                                 ;* SRAM is also defined 
                                 ;* 
                                 ;* The Register names are represented by their hexadecimal address.
                                 ;* 
                                 ;* The Register Bit names are represented by their bit number (0-7).
                                 ;* 
                                 ;* Please observe the difference in using the bit names with instructions
                                 ;* such as "sbr"/"cbr" (set/clear bit in register) and "sbrs"/"sbrc"
                                 ;* (skip if bit in register set/cleared). The following example illustrates
                                 ;* this:
                                 ;* 
                                 ;* in    r16,PORTB             ;read PORTB latch
                                 ;* sbr   r16,(1<<PB6)+(1<<PB5) ;set PB6 and PB5 (use masks, not bit#)
                                 ;* out   PORTB,r16             ;output to PORTB
                                 ;* 
                                 ;* in    r16,TIFR              ;read the Timer Interrupt Flag Register
                                 ;* sbrc  r16,TOV0              ;test the overflow flag (use bit#)
                                 ;* rjmp  TOV0_is_set           ;jump if set
                                 ;* ...                         ;otherwise do something else
                                 ;*************************************************************************
                                 
                                 #ifndef _M128DEF_INC_
                                 #define _M128DEF_INC_
                                 
                                 
                                 #pragma partinc 0
                                 
                                 ; ***** SPECIFY DEVICE ***************************************************
                                 .device ATmega128
                                 #pragma AVRPART ADMIN PART_NAME ATmega128
                                 .equ	SIGNATURE_000	= 0x1e
                                 .equ	SIGNATURE_001	= 0x97
                                 .equ	SIGNATURE_002	= 0x02
                                 
                                 #pragma AVRPART CORE CORE_VERSION V2E
                                 
                                 
                                 ; ***** I/O REGISTER DEFINITIONS *****************************************
                                 ; NOTE:
                                 ; Definitions marked "MEMORY MAPPED"are extended I/O ports
                                 ; and cannot be used with IN/OUT instructions
                                 .equ	UCSR1C	= 0x9d	; MEMORY MAPPED
                                 .equ	UDR1	= 0x9c	; MEMORY MAPPED
                                 .equ	UCSR1A	= 0x9b	; MEMORY MAPPED
                                 .equ	UCSR1B	= 0x9a	; MEMORY MAPPED
                                 .equ	UBRR1H	= 0x98	; MEMORY MAPPED
                                 .equ	UBRR1L	= 0x99	; MEMORY MAPPED
                                 .equ	UCSR0C	= 0x95	; MEMORY MAPPED
                                 .equ	UBRR0H	= 0x90	; MEMORY MAPPED
                                 .equ	TCCR3C	= 0x8c	; MEMORY MAPPED
                                 .equ	TCCR3A	= 0x8b	; MEMORY MAPPED
                                 .equ	TCCR3B	= 0x8a	; MEMORY MAPPED
                                 .equ	TCNT3L	= 0x88	; MEMORY MAPPED
                                 .equ	TCNT3H	= 0x89	; MEMORY MAPPED
                                 .equ	OCR3AL	= 0x86	; MEMORY MAPPED
                                 .equ	OCR3AH	= 0x87	; MEMORY MAPPED
                                 .equ	OCR3BL	= 0x84	; MEMORY MAPPED
                                 .equ	OCR3BH	= 0x85	; MEMORY MAPPED
                                 .equ	OCR3CL	= 0x82	; MEMORY MAPPED
                                 .equ	OCR3CH	= 0x83	; MEMORY MAPPED
                                 .equ	ICR3L	= 0x80	; MEMORY MAPPED
                                 .equ	ICR3H	= 0x81	; MEMORY MAPPED
                                 .equ	ETIMSK	= 0x7d	; MEMORY MAPPED
                                 .equ	ETIFR	= 0x7c	; MEMORY MAPPED
                                 .equ	TCCR1C	= 0x7a	; MEMORY MAPPED
                                 .equ	OCR1CL	= 0x78	; MEMORY MAPPED
                                 .equ	OCR1CH	= 0x79	; MEMORY MAPPED
                                 .equ	TWCR	= 0x74	; MEMORY MAPPED
                                 .equ	TWDR	= 0x73	; MEMORY MAPPED
                                 .equ	TWAR	= 0x72	; MEMORY MAPPED
                                 .equ	TWSR	= 0x71	; MEMORY MAPPED
                                 .equ	TWBR	= 0x70	; MEMORY MAPPED
                                 .equ	OSCCAL	= 0x6f	; MEMORY MAPPED
                                 .equ	XMCRA	= 0x6d	; MEMORY MAPPED
                                 .equ	XMCRB	= 0x6c	; MEMORY MAPPED
                                 .equ	EICRA	= 0x6a	; MEMORY MAPPED
                                 .equ	SPMCSR	= 0x68	; MEMORY MAPPED
                                 .equ	PORTG	= 0x65	; MEMORY MAPPED
                                 .equ	DDRG	= 0x64	; MEMORY MAPPED
                                 .equ	PING	= 0x63	; MEMORY MAPPED
                                 .equ	PORTF	= 0x62	; MEMORY MAPPED
                                 .equ	DDRF	= 0x61	; MEMORY MAPPED
                                 .equ	SREG	= 0x3f
                                 .equ	SPL	= 0x3d
                                 .equ	SPH	= 0x3e
                                 .equ	XDIV	= 0x3c
                                 .equ	RAMPZ	= 0x3b
                                 .equ	EICRB	= 0x3a
                                 .equ	EIMSK	= 0x39
                                 .equ	EIFR	= 0x38
                                 .equ	TIMSK	= 0x37
                                 .equ	TIFR	= 0x36
                                 .equ	MCUCR	= 0x35
                                 .equ	MCUCSR	= 0x34
                                 .equ	TCCR0	= 0x33
                                 .equ	TCNT0	= 0x32
                                 .equ	OCR0	= 0x31
                                 .equ	ASSR	= 0x30
                                 .equ	TCCR1A	= 0x2f
                                 .equ	TCCR1B	= 0x2e
                                 .equ	TCNT1L	= 0x2c
                                 .equ	TCNT1H	= 0x2d
                                 .equ	OCR1AL	= 0x2a
                                 .equ	OCR1AH	= 0x2b
                                 .equ	OCR1BL	= 0x28
                                 .equ	OCR1BH	= 0x29
                                 .equ	ICR1L	= 0x26
                                 .equ	ICR1H	= 0x27
                                 .equ	TCCR2	= 0x25
                                 .equ	TCNT2	= 0x24
                                 .equ	OCR2	= 0x23
                                 .equ	OCDR	= 0x22
                                 .equ	WDTCR	= 0x21
                                 .equ	SFIOR	= 0x20
                                 .equ	EEARL	= 0x1e
                                 .equ	EEARH	= 0x1f
                                 .equ	EEDR	= 0x1d
                                 .equ	EECR	= 0x1c
                                 .equ	PORTA	= 0x1b
                                 .equ	DDRA	= 0x1a
                                 .equ	PINA	= 0x19
                                 .equ	PORTB	= 0x18
                                 .equ	DDRB	= 0x17
                                 .equ	PINB	= 0x16
                                 .equ	PORTC	= 0x15
                                 .equ	DDRC	= 0x14
                                 .equ	PINC	= 0x13
                                 .equ	PORTD	= 0x12
                                 .equ	DDRD	= 0x11
                                 .equ	PIND	= 0x10
                                 .equ	SPDR	= 0x0f
                                 .equ	SPSR	= 0x0e
                                 .equ	SPCR	= 0x0d
                                 .equ	UDR0	= 0x0c
                                 .equ	UCSR0A	= 0x0b
                                 .equ	UCSR0B	= 0x0a
                                 .equ	UBRR0L	= 0x09
                                 .equ	ACSR	= 0x08
                                 .equ	ADMUX	= 0x07
                                 .equ	ADCSRA	= 0x06
                                 .equ	ADCH	= 0x05
                                 .equ	ADCL	= 0x04
                                 .equ	PORTE	= 0x03
                                 .equ	DDRE	= 0x02
                                 .equ	PINE	= 0x01
                                 .equ	PINF	= 0x00
                                 
                                 
                                 ; ***** BIT DEFINITIONS **************************************************
                                 
                                 ; ***** ANALOG_COMPARATOR ************
                                 ; SFIOR - Special Function IO Register
                                 .equ	ACME	= 3	; Analog Comparator Multiplexer Enable
                                 
                                 ; ACSR - Analog Comparator Control And Status Register
                                 .equ	ACIS0	= 0	; Analog Comparator Interrupt Mode Select bit 0
                                 .equ	ACIS1	= 1	; Analog Comparator Interrupt Mode Select bit 1
                                 .equ	ACIC	= 2	; Analog Comparator Input Capture Enable
                                 .equ	ACIE	= 3	; Analog Comparator Interrupt Enable
                                 .equ	ACI	= 4	; Analog Comparator Interrupt Flag
                                 .equ	ACO	= 5	; Analog Compare Output
                                 .equ	ACBG	= 6	; Analog Comparator Bandgap Select
                                 .equ	ACD	= 7	; Analog Comparator Disable
                                 
                                 
                                 ; ***** SPI **************************
                                 ; SPDR - SPI Data Register
                                 .equ	SPDR0	= 0	; SPI Data Register bit 0
                                 .equ	SPDR1	= 1	; SPI Data Register bit 1
                                 .equ	SPDR2	= 2	; SPI Data Register bit 2
                                 .equ	SPDR3	= 3	; SPI Data Register bit 3
                                 .equ	SPDR4	= 4	; SPI Data Register bit 4
                                 .equ	SPDR5	= 5	; SPI Data Register bit 5
                                 .equ	SPDR6	= 6	; SPI Data Register bit 6
                                 .equ	SPDR7	= 7	; SPI Data Register bit 7
                                 
                                 ; SPSR - SPI Status Register
                                 .equ	SPI2X	= 0	; Double SPI Speed Bit
                                 .equ	WCOL	= 6	; Write Collision Flag
                                 .equ	SPIF	= 7	; SPI Interrupt Flag
                                 
                                 ; SPCR - SPI Control Register
                                 .equ	SPR0	= 0	; SPI Clock Rate Select 0
                                 .equ	SPR1	= 1	; SPI Clock Rate Select 1
                                 .equ	CPHA	= 2	; Clock Phase
                                 .equ	CPOL	= 3	; Clock polarity
                                 .equ	MSTR	= 4	; Master/Slave Select
                                 .equ	DORD	= 5	; Data Order
                                 .equ	SPE	= 6	; SPI Enable
                                 .equ	SPIE	= 7	; SPI Interrupt Enable
                                 
                                 
                                 ; ***** TWI **************************
                                 ; TWBR - TWI Bit Rate register
                                 .equ	I2BR	= TWBR	; For compatibility
                                 .equ	TWBR0	= 0	; 
                                 .equ	TWBR1	= 1	; 
                                 .equ	TWBR2	= 2	; 
                                 .equ	TWBR3	= 3	; 
                                 .equ	TWBR4	= 4	; 
                                 .equ	TWBR5	= 5	; 
                                 .equ	TWBR6	= 6	; 
                                 .equ	TWBR7	= 7	; 
                                 
                                 ; TWCR - TWI Control Register
                                 .equ	I2CR	= TWCR	; For compatibility
                                 .equ	TWIE	= 0	; TWI Interrupt Enable
                                 .equ	I2IE	= TWIE	; For compatibility
                                 .equ	TWEN	= 2	; TWI Enable Bit
                                 .equ	I2EN	= TWEN	; For compatibility
                                 .equ	ENI2C	= TWEN	; For compatibility
                                 .equ	TWWC	= 3	; TWI Write Collition Flag
                                 .equ	I2WC	= TWWC	; For compatibility
                                 .equ	TWSTO	= 4	; TWI Stop Condition Bit
                                 .equ	I2STO	= TWSTO	; For compatibility
                                 .equ	TWSTA	= 5	; TWI Start Condition Bit
                                 .equ	I2STA	= TWSTA	; For compatibility
                                 .equ	TWEA	= 6	; TWI Enable Acknowledge Bit
                                 .equ	I2EA	= TWEA	; For compatibility
                                 .equ	TWINT	= 7	; TWI Interrupt Flag
                                 .equ	I2INT	= TWINT	; For compatibility
                                 
                                 ; TWSR - TWI Status Register
                                 .equ	I2SR	= TWSR	; For compatibility
                                 .equ	TWPS0	= 0	; TWI Prescaler
                                 .equ	TWS0	= TWPS0	; For compatibility
                                 .equ	I2GCE	= TWPS0	; For compatibility
                                 .equ	TWPS1	= 1	; TWI Prescaler
                                 .equ	TWS1	= TWPS1	; For compatibility
                                 .equ	TWS3	= 3	; TWI Status
                                 .equ	I2S3	= TWS3	; For compatibility
                                 .equ	TWS4	= 4	; TWI Status
                                 .equ	I2S4	= TWS4	; For compatibility
                                 .equ	TWS5	= 5	; TWI Status
                                 .equ	I2S5	= TWS5	; For compatibility
                                 .equ	TWS6	= 6	; TWI Status
                                 .equ	I2S6	= TWS6	; For compatibility
                                 .equ	TWS7	= 7	; TWI Status
                                 .equ	I2S7	= TWS7	; For compatibility
                                 
                                 ; TWDR - TWI Data register
                                 .equ	I2DR	= TWDR	; For compatibility
                                 .equ	TWD0	= 0	; TWI Data Register Bit 0
                                 .equ	TWD1	= 1	; TWI Data Register Bit 1
                                 .equ	TWD2	= 2	; TWI Data Register Bit 2
                                 .equ	TWD3	= 3	; TWI Data Register Bit 3
                                 .equ	TWD4	= 4	; TWI Data Register Bit 4
                                 .equ	TWD5	= 5	; TWI Data Register Bit 5
                                 .equ	TWD6	= 6	; TWI Data Register Bit 6
                                 .equ	TWD7	= 7	; TWI Data Register Bit 7
                                 
                                 ; TWAR - TWI (Slave) Address register
                                 .equ	I2AR	= TWAR	; For compatibility
                                 .equ	TWGCE	= 0	; TWI General Call Recognition Enable Bit
                                 .equ	TWA0	= 1	; TWI (Slave) Address register Bit 0
                                 .equ	TWA1	= 2	; TWI (Slave) Address register Bit 1
                                 .equ	TWA2	= 3	; TWI (Slave) Address register Bit 2
                                 .equ	TWA3	= 4	; TWI (Slave) Address register Bit 3
                                 .equ	TWA4	= 5	; TWI (Slave) Address register Bit 4
                                 .equ	TWA5	= 6	; TWI (Slave) Address register Bit 5
                                 .equ	TWA6	= 7	; TWI (Slave) Address register Bit 6
                                 
                                 
                                 ; ***** USART0 ***********************
                                 ; UDR0 - USART I/O Data Register
                                 .equ	UDR00	= 0	; USART I/O Data Register bit 0
                                 .equ	UDR01	= 1	; USART I/O Data Register bit 1
                                 .equ	UDR02	= 2	; USART I/O Data Register bit 2
                                 .equ	UDR03	= 3	; USART I/O Data Register bit 3
                                 .equ	UDR04	= 4	; USART I/O Data Register bit 4
                                 .equ	UDR05	= 5	; USART I/O Data Register bit 5
                                 .equ	UDR06	= 6	; USART I/O Data Register bit 6
                                 .equ	UDR07	= 7	; USART I/O Data Register bit 7
                                 
                                 ; UCSR0A - USART Control and Status Register A
                                 .equ	MPCM0	= 0	; Multi-processor Communication Mode
                                 .equ	U2X0	= 1	; Double the USART transmission speed
                                 .equ	UPE0	= 2	; Parity Error
                                 .equ	DOR0	= 3	; Data overRun
                                 .equ	FE0	= 4	; Framing Error
                                 .equ	UDRE0	= 5	; USART Data Register Empty
                                 .equ	TXC0	= 6	; USART Transmitt Complete
                                 .equ	RXC0	= 7	; USART Receive Complete
                                 
                                 ; UCSR0B - USART Control and Status Register B
                                 .equ	TXB80	= 0	; Transmit Data Bit 8
                                 .equ	RXB80	= 1	; Receive Data Bit 8
                                 .equ	UCSZ02	= 2	; Character Size
                                 .equ	UCSZ2	= UCSZ02	; For compatibility
                                 .equ	TXEN0	= 3	; Transmitter Enable
                                 .equ	RXEN0	= 4	; Receiver Enable
                                 .equ	UDRIE0	= 5	; USART Data register Empty Interrupt Enable
                                 .equ	TXCIE0	= 6	; TX Complete Interrupt Enable
                                 .equ	RXCIE0	= 7	; RX Complete Interrupt Enable
                                 
                                 ; UCSR0C - USART Control and Status Register C
                                 .equ	UCPOL0	= 0	; Clock Polarity
                                 .equ	UCSZ00	= 1	; Character Size
                                 .equ	UCSZ01	= 2	; Character Size
                                 .equ	USBS0	= 3	; Stop Bit Select
                                 .equ	UPM00	= 4	; Parity Mode Bit 0
                                 .equ	UPM01	= 5	; Parity Mode Bit 1
                                 .equ	UMSEL0	= 6	; USART Mode Select
                                 
                                 ; UBRR0H - USART Baud Rate Register Hight Byte
                                 .equ	UBRR8	= 0	; USART Baud Rate Register bit 8
                                 .equ	UBRR9	= 1	; USART Baud Rate Register bit 9
                                 .equ	UBRR10	= 2	; USART Baud Rate Register bit 10
                                 .equ	UBRR11	= 3	; USART Baud Rate Register bit 11
                                 
                                 ; UBRR0L - USART Baud Rate Register Low Byte
                                 .equ	UBRR0	= 0	; USART Baud Rate Register bit 0
                                 .equ	UBRR1	= 1	; USART Baud Rate Register bit 1
                                 .equ	UBRR2	= 2	; USART Baud Rate Register bit 2
                                 .equ	UBRR3	= 3	; USART Baud Rate Register bit 3
                                 .equ	UBRR4	= 4	; USART Baud Rate Register bit 4
                                 .equ	UBRR5	= 5	; USART Baud Rate Register bit 5
                                 .equ	UBRR6	= 6	; USART Baud Rate Register bit 6
                                 .equ	UBRR7	= 7	; USART Baud Rate Register bit 7
                                 
                                 
                                 ; ***** USART1 ***********************
                                 ; UDR1 - USART I/O Data Register
                                 .equ	UDR10	= 0	; USART I/O Data Register bit 0
                                 .equ	UDR11	= 1	; USART I/O Data Register bit 1
                                 .equ	UDR12	= 2	; USART I/O Data Register bit 2
                                 .equ	UDR13	= 3	; USART I/O Data Register bit 3
                                 .equ	UDR14	= 4	; USART I/O Data Register bit 4
                                 .equ	UDR15	= 5	; USART I/O Data Register bit 5
                                 .equ	UDR16	= 6	; USART I/O Data Register bit 6
                                 .equ	UDR17	= 7	; USART I/O Data Register bit 7
                                 
                                 ; UCSR1A - USART Control and Status Register A
                                 .equ	MPCM1	= 0	; Multi-processor Communication Mode
                                 .equ	U2X1	= 1	; Double the USART transmission speed
                                 .equ	UPE1	= 2	; Parity Error
                                 .equ	DOR1	= 3	; Data overRun
                                 .equ	FE1	= 4	; Framing Error
                                 .equ	UDRE1	= 5	; USART Data Register Empty
                                 .equ	TXC1	= 6	; USART Transmitt Complete
                                 .equ	RXC1	= 7	; USART Receive Complete
                                 
                                 ; UCSR1B - USART Control and Status Register B
                                 .equ	TXB81	= 0	; Transmit Data Bit 8
                                 .equ	RXB81	= 1	; Receive Data Bit 8
                                 .equ	UCSZ12	= 2	; Character Size
                                 .equ	TXEN1	= 3	; Transmitter Enable
                                 .equ	RXEN1	= 4	; Receiver Enable
                                 .equ	UDRIE1	= 5	; USART Data register Empty Interrupt Enable
                                 .equ	TXCIE1	= 6	; TX Complete Interrupt Enable
                                 .equ	RXCIE1	= 7	; RX Complete Interrupt Enable
                                 
                                 ; UCSR1C - USART Control and Status Register C
                                 .equ	UCPOL1	= 0	; Clock Polarity
                                 .equ	UCSZ10	= 1	; Character Size
                                 .equ	UCSZ11	= 2	; Character Size
                                 .equ	USBS1	= 3	; Stop Bit Select
                                 .equ	UPM10	= 4	; Parity Mode Bit 0
                                 .equ	UPM11	= 5	; Parity Mode Bit 1
                                 .equ	UMSEL1	= 6	; USART Mode Select
                                 
                                 ; UBRR1H - USART Baud Rate Register Hight Byte
                                 ;.equ	UBRR8	= 0	; USART Baud Rate Register bit 8
                                 ;.equ	UBRR9	= 1	; USART Baud Rate Register bit 9
                                 ;.equ	UBRR10	= 2	; USART Baud Rate Register bit 10
                                 ;.equ	UBRR11	= 3	; USART Baud Rate Register bit 11
                                 
                                 ; UBRR1L - USART Baud Rate Register Low Byte
                                 ;.equ	UBRR0	= 0	; USART Baud Rate Register bit 0
                                 ;.equ	UBRR1	= 1	; USART Baud Rate Register bit 1
                                 ;.equ	UBRR2	= 2	; USART Baud Rate Register bit 2
                                 ;.equ	UBRR3	= 3	; USART Baud Rate Register bit 3
                                 ;.equ	UBRR4	= 4	; USART Baud Rate Register bit 4
                                 ;.equ	UBRR5	= 5	; USART Baud Rate Register bit 5
                                 ;.equ	UBRR6	= 6	; USART Baud Rate Register bit 6
                                 ;.equ	UBRR7	= 7	; USART Baud Rate Register bit 7
                                 
                                 
                                 ; ***** CPU **************************
                                 ; SREG - Status Register
                                 .equ	SREG_C	= 0	; Carry Flag
                                 .equ	SREG_Z	= 1	; Zero Flag
                                 .equ	SREG_N	= 2	; Negative Flag
                                 .equ	SREG_V	= 3	; Two's Complement Overflow Flag
                                 .equ	SREG_S	= 4	; Sign Bit
                                 .equ	SREG_H	= 5	; Half Carry Flag
                                 .equ	SREG_T	= 6	; Bit Copy Storage
                                 .equ	SREG_I	= 7	; Global Interrupt Enable
                                 
                                 ; MCUCR - MCU Control Register
                                 .equ	IVCE	= 0	; Interrupt Vector Change Enable
                                 .equ	IVSEL	= 1	; Interrupt Vector Select
                                 .equ	SM2	= 2	; Sleep Mode Select
                                 .equ	SM0	= 3	; Sleep Mode Select
                                 .equ	SM1	= 4	; Sleep Mode Select
                                 .equ	SE	= 5	; Sleep Enable
                                 .equ	SRW10	= 6	; External SRAM Wait State Select
                                 .equ	SRE	= 7	; External SRAM Enable
                                 
                                 ; XMCRA - External Memory Control Register A
                                 .equ	SRW11	= 1	; Wait state select bit upper page
                                 .equ	SRW00	= 2	; Wait state select bit lower page
                                 .equ	SRW01	= 3	; Wait state select bit lower page
                                 .equ	SRL0	= 4	; Wait state page limit
                                 .equ	SRL1	= 5	; Wait state page limit
                                 .equ	SRL2	= 6	; Wait state page limit
                                 
                                 ; XMCRB - External Memory Control Register B
                                 .equ	XMM0	= 0	; External Memory High Mask
                                 .equ	XMM1	= 1	; External Memory High Mask
                                 .equ	XMM2	= 2	; External Memory High Mask
                                 .equ	XMBK	= 7	; External Memory Bus Keeper Enable
                                 
                                 ; OSCCAL - Oscillator Calibration Value
                                 .equ	CAL0	= 0	; Oscillator Calibration Value
                                 .equ	CAL1	= 1	; Oscillator Calibration Value
                                 .equ	CAL2	= 2	; Oscillator Calibration Value
                                 .equ	CAL3	= 3	; Oscillator Calibration Value
                                 .equ	CAL4	= 4	; Oscillator Calibration Value
                                 .equ	CAL5	= 5	; Oscillator Calibration Value
                                 .equ	CAL6	= 6	; Oscillator Calibration Value
                                 .equ	CAL7	= 7	; Oscillator Calibration Value
                                 
                                 ; XDIV - XTAL Divide Control Register
                                 .equ	XDIV0	= 0	; XTAl Divide Select Bit 0
                                 .equ	XDIV1	= 1	; XTAl Divide Select Bit 1
                                 .equ	XDIV2	= 2	; XTAl Divide Select Bit 2
                                 .equ	XDIV3	= 3	; XTAl Divide Select Bit 3
                                 .equ	XDIV4	= 4	; XTAl Divide Select Bit 4
                                 .equ	XDIV5	= 5	; XTAl Divide Select Bit 5
                                 .equ	XDIV6	= 6	; XTAl Divide Select Bit 6
                                 .equ	XDIVEN	= 7	; XTAL Divide Enable
                                 
                                 ; MCUCSR - MCU Control And Status Register
                                 .equ	PORF	= 0	; Power-on reset flag
                                 .equ	EXTRF	= 1	; External Reset Flag
                                 .equ	BORF	= 2	; Brown-out Reset Flag
                                 .equ	WDRF	= 3	; Watchdog Reset Flag
                                 .equ	JTRF	= 4	; JTAG Reset Flag
                                 .equ	JTD	= 7	; JTAG Interface Disable
                                 
                                 ; RAMPZ - RAM Page Z Select Register
                                 .equ	RAMPZ0	= 0	; RAM Page Z Select Register Bit 0
                                 
                                 
                                 ; ***** BOOT_LOAD ********************
                                 ; SPMCSR - Store Program Memory Control Register
                                 .equ	SPMCR	= SPMCSR	; For compatibility
                                 .equ	SPMEN	= 0	; Store Program Memory Enable
                                 .equ	PGERS	= 1	; Page Erase
                                 .equ	PGWRT	= 2	; Page Write
                                 .equ	BLBSET	= 3	; Boot Lock Bit Set
                                 .equ	RWWSRE	= 4	; Read While Write section read enable
                                 .equ	ASRE	= RWWSRE	; For compatibility
                                 .equ	RWWSB	= 6	; Read While Write Section Busy
                                 .equ	ASB	= RWWSB	; For compatibility
                                 .equ	SPMIE	= 7	; SPM Interrupt Enable
                                 
                                 
                                 ; ***** JTAG *************************
                                 ; OCDR - On-Chip Debug Related Register in I/O Memory
                                 .equ	OCDR0	= 0	; On-Chip Debug Register Bit 0
                                 .equ	OCDR1	= 1	; On-Chip Debug Register Bit 1
                                 .equ	OCDR2	= 2	; On-Chip Debug Register Bit 2
                                 .equ	OCDR3	= 3	; On-Chip Debug Register Bit 3
                                 .equ	OCDR4	= 4	; On-Chip Debug Register Bit 4
                                 .equ	OCDR5	= 5	; On-Chip Debug Register Bit 5
                                 .equ	OCDR6	= 6	; On-Chip Debug Register Bit 6
                                 .equ	OCDR7	= 7	; On-Chip Debug Register Bit 7
                                 .equ	IDRD	= OCDR7	; For compatibility
                                 
                                 ; MCUCSR - MCU Control And Status Register
                                 ;.equ	JTRF	= 4	; JTAG Reset Flag
                                 ;.equ	JTD	= 7	; JTAG Interface Disable
                                 
                                 
                                 ; ***** MISC *************************
                                 ; SFIOR - Special Function IO Register
                                 .equ	PSR321	= 0	; Prescaler Reset Timer/Counter3, Timer/Counter2, and Timer/Counter1
                                 .equ	PSR1	= PSR321	; For compatibility
                                 .equ	PSR2	= PSR321	; For compatibility
                                 .equ	PSR3	= PSR321	; For compatibility
                                 .equ	PSR0	= 1	; Prescaler Reset Timer/Counter0
                                 .equ	PUD	= 2	; Pull Up Disable
                                 ;.equ	ACME	= 3	; Analog Comparator Multiplexer Enable
                                 .equ	TSM	= 7	; Timer/Counter Synchronization Mode
                                 
                                 
                                 ; ***** EXTERNAL_INTERRUPT ***********
                                 ; EICRA - External Interrupt Control Register A
                                 .equ	ISC00	= 0	; External Interrupt Sense Control Bit
                                 .equ	ISC01	= 1	; External Interrupt Sense Control Bit
                                 .equ	ISC10	= 2	; External Interrupt Sense Control Bit
                                 .equ	ISC11	= 3	; External Interrupt Sense Control Bit
                                 .equ	ISC20	= 4	; External Interrupt Sense Control Bit
                                 .equ	ISC21	= 5	; External Interrupt Sense Control Bit
                                 .equ	ISC30	= 6	; External Interrupt Sense Control Bit
                                 .equ	ISC31	= 7	; External Interrupt Sense Control Bit
                                 
                                 ; EICRB - External Interrupt Control Register B
                                 .equ	ISC40	= 0	; External Interrupt 7-4 Sense Control Bit
                                 .equ	ISC41	= 1	; External Interrupt 7-4 Sense Control Bit
                                 .equ	ISC50	= 2	; External Interrupt 7-4 Sense Control Bit
                                 .equ	ISC51	= 3	; External Interrupt 7-4 Sense Control Bit
                                 .equ	ISC60	= 4	; External Interrupt 7-4 Sense Control Bit
                                 .equ	ISC61	= 5	; External Interrupt 7-4 Sense Control Bit
                                 .equ	ISC70	= 6	; External Interrupt 7-4 Sense Control Bit
                                 .equ	ISC71	= 7	; External Interrupt 7-4 Sense Control Bit
                                 
                                 ; EIMSK - External Interrupt Mask Register
                                 .equ	GICR	= EIMSK	; For compatibility
                                 .equ	GIMSK	= EIMSK	; For compatibility
                                 .equ	INT0	= 0	; External Interrupt Request 0 Enable
                                 .equ	INT1	= 1	; External Interrupt Request 1 Enable
                                 .equ	INT2	= 2	; External Interrupt Request 2 Enable
                                 .equ	INT3	= 3	; External Interrupt Request 3 Enable
                                 .equ	INT4	= 4	; External Interrupt Request 4 Enable
                                 .equ	INT5	= 5	; External Interrupt Request 5 Enable
                                 .equ	INT6	= 6	; External Interrupt Request 6 Enable
                                 .equ	INT7	= 7	; External Interrupt Request 7 Enable
                                 
                                 ; EIFR - External Interrupt Flag Register
                                 .equ	GIFR	= EIFR	; For compatibility
                                 .equ	INTF0	= 0	; External Interrupt Flag 0
                                 .equ	INTF1	= 1	; External Interrupt Flag 1
                                 .equ	INTF2	= 2	; External Interrupt Flag 2
                                 .equ	INTF3	= 3	; External Interrupt Flag 3
                                 .equ	INTF4	= 4	; External Interrupt Flag 4
                                 .equ	INTF5	= 5	; External Interrupt Flag 5
                                 .equ	INTF6	= 6	; External Interrupt Flag 6
                                 .equ	INTF7	= 7	; External Interrupt Flag 7
                                 
                                 
                                 ; ***** EEPROM ***********************
                                 ; EEDR - EEPROM Data Register
                                 .equ	EEDR0	= 0	; EEPROM Data Register bit 0
                                 .equ	EEDR1	= 1	; EEPROM Data Register bit 1
                                 .equ	EEDR2	= 2	; EEPROM Data Register bit 2
                                 .equ	EEDR3	= 3	; EEPROM Data Register bit 3
                                 .equ	EEDR4	= 4	; EEPROM Data Register bit 4
                                 .equ	EEDR5	= 5	; EEPROM Data Register bit 5
                                 .equ	EEDR6	= 6	; EEPROM Data Register bit 6
                                 .equ	EEDR7	= 7	; EEPROM Data Register bit 7
                                 
                                 ; EECR - EEPROM Control Register
                                 .equ	EERE	= 0	; EEPROM Read Enable
                                 .equ	EEWE	= 1	; EEPROM Write Enable
                                 .equ	EEMWE	= 2	; EEPROM Master Write Enable
                                 .equ	EERIE	= 3	; EEPROM Ready Interrupt Enable
                                 
                                 
                                 ; ***** PORTA ************************
                                 ; PORTA - Port A Data Register
                                 .equ	PORTA0	= 0	; Port A Data Register bit 0
                                 .equ	PA0	= 0	; For compatibility
                                 .equ	PORTA1	= 1	; Port A Data Register bit 1
                                 .equ	PA1	= 1	; For compatibility
                                 .equ	PORTA2	= 2	; Port A Data Register bit 2
                                 .equ	PA2	= 2	; For compatibility
                                 .equ	PORTA3	= 3	; Port A Data Register bit 3
                                 .equ	PA3	= 3	; For compatibility
                                 .equ	PORTA4	= 4	; Port A Data Register bit 4
                                 .equ	PA4	= 4	; For compatibility
                                 .equ	PORTA5	= 5	; Port A Data Register bit 5
                                 .equ	PA5	= 5	; For compatibility
                                 .equ	PORTA6	= 6	; Port A Data Register bit 6
                                 .equ	PA6	= 6	; For compatibility
                                 .equ	PORTA7	= 7	; Port A Data Register bit 7
                                 .equ	PA7	= 7	; For compatibility
                                 
                                 ; DDRA - Port A Data Direction Register
                                 .equ	DDA0	= 0	; Data Direction Register, Port A, bit 0
                                 .equ	DDA1	= 1	; Data Direction Register, Port A, bit 1
                                 .equ	DDA2	= 2	; Data Direction Register, Port A, bit 2
                                 .equ	DDA3	= 3	; Data Direction Register, Port A, bit 3
                                 .equ	DDA4	= 4	; Data Direction Register, Port A, bit 4
                                 .equ	DDA5	= 5	; Data Direction Register, Port A, bit 5
                                 .equ	DDA6	= 6	; Data Direction Register, Port A, bit 6
                                 .equ	DDA7	= 7	; Data Direction Register, Port A, bit 7
                                 
                                 ; PINA - Port A Input Pins
                                 .equ	PINA0	= 0	; Input Pins, Port A bit 0
                                 .equ	PINA1	= 1	; Input Pins, Port A bit 1
                                 .equ	PINA2	= 2	; Input Pins, Port A bit 2
                                 .equ	PINA3	= 3	; Input Pins, Port A bit 3
                                 .equ	PINA4	= 4	; Input Pins, Port A bit 4
                                 .equ	PINA5	= 5	; Input Pins, Port A bit 5
                                 .equ	PINA6	= 6	; Input Pins, Port A bit 6
                                 .equ	PINA7	= 7	; Input Pins, Port A bit 7
                                 
                                 
                                 ; ***** PORTB ************************
                                 ; PORTB - Port B Data Register
                                 .equ	PORTB0	= 0	; Port B Data Register bit 0
                                 .equ	PB0	= 0	; For compatibility
                                 .equ	PORTB1	= 1	; Port B Data Register bit 1
                                 .equ	PB1	= 1	; For compatibility
                                 .equ	PORTB2	= 2	; Port B Data Register bit 2
                                 .equ	PB2	= 2	; For compatibility
                                 .equ	PORTB3	= 3	; Port B Data Register bit 3
                                 .equ	PB3	= 3	; For compatibility
                                 .equ	PORTB4	= 4	; Port B Data Register bit 4
                                 .equ	PB4	= 4	; For compatibility
                                 .equ	PORTB5	= 5	; Port B Data Register bit 5
                                 .equ	PB5	= 5	; For compatibility
                                 .equ	PORTB6	= 6	; Port B Data Register bit 6
                                 .equ	PB6	= 6	; For compatibility
                                 .equ	PORTB7	= 7	; Port B Data Register bit 7
                                 .equ	PB7	= 7	; For compatibility
                                 
                                 ; DDRB - Port B Data Direction Register
                                 .equ	DDB0	= 0	; Port B Data Direction Register bit 0
                                 .equ	DDB1	= 1	; Port B Data Direction Register bit 1
                                 .equ	DDB2	= 2	; Port B Data Direction Register bit 2
                                 .equ	DDB3	= 3	; Port B Data Direction Register bit 3
                                 .equ	DDB4	= 4	; Port B Data Direction Register bit 4
                                 .equ	DDB5	= 5	; Port B Data Direction Register bit 5
                                 .equ	DDB6	= 6	; Port B Data Direction Register bit 6
                                 .equ	DDB7	= 7	; Port B Data Direction Register bit 7
                                 
                                 ; PINB - Port B Input Pins
                                 .equ	PINB0	= 0	; Port B Input Pins bit 0
                                 .equ	PINB1	= 1	; Port B Input Pins bit 1
                                 .equ	PINB2	= 2	; Port B Input Pins bit 2
                                 .equ	PINB3	= 3	; Port B Input Pins bit 3
                                 .equ	PINB4	= 4	; Port B Input Pins bit 4
                                 .equ	PINB5	= 5	; Port B Input Pins bit 5
                                 .equ	PINB6	= 6	; Port B Input Pins bit 6
                                 .equ	PINB7	= 7	; Port B Input Pins bit 7
                                 
                                 
                                 ; ***** PORTC ************************
                                 ; PORTC - Port C Data Register
                                 .equ	PORTC0	= 0	; Port C Data Register bit 0
                                 .equ	PC0	= 0	; For compatibility
                                 .equ	PORTC1	= 1	; Port C Data Register bit 1
                                 .equ	PC1	= 1	; For compatibility
                                 .equ	PORTC2	= 2	; Port C Data Register bit 2
                                 .equ	PC2	= 2	; For compatibility
                                 .equ	PORTC3	= 3	; Port C Data Register bit 3
                                 .equ	PC3	= 3	; For compatibility
                                 .equ	PORTC4	= 4	; Port C Data Register bit 4
                                 .equ	PC4	= 4	; For compatibility
                                 .equ	PORTC5	= 5	; Port C Data Register bit 5
                                 .equ	PC5	= 5	; For compatibility
                                 .equ	PORTC6	= 6	; Port C Data Register bit 6
                                 .equ	PC6	= 6	; For compatibility
                                 .equ	PORTC7	= 7	; Port C Data Register bit 7
                                 .equ	PC7	= 7	; For compatibility
                                 
                                 ; DDRC - Port C Data Direction Register
                                 .equ	DDC0	= 0	; Port C Data Direction Register bit 0
                                 .equ	DDC1	= 1	; Port C Data Direction Register bit 1
                                 .equ	DDC2	= 2	; Port C Data Direction Register bit 2
                                 .equ	DDC3	= 3	; Port C Data Direction Register bit 3
                                 .equ	DDC4	= 4	; Port C Data Direction Register bit 4
                                 .equ	DDC5	= 5	; Port C Data Direction Register bit 5
                                 .equ	DDC6	= 6	; Port C Data Direction Register bit 6
                                 .equ	DDC7	= 7	; Port C Data Direction Register bit 7
                                 
                                 ; PINC - Port C Input Pins
                                 .equ	PINC0	= 0	; Port C Input Pins bit 0
                                 .equ	PINC1	= 1	; Port C Input Pins bit 1
                                 .equ	PINC2	= 2	; Port C Input Pins bit 2
                                 .equ	PINC3	= 3	; Port C Input Pins bit 3
                                 .equ	PINC4	= 4	; Port C Input Pins bit 4
                                 .equ	PINC5	= 5	; Port C Input Pins bit 5
                                 .equ	PINC6	= 6	; Port C Input Pins bit 6
                                 .equ	PINC7	= 7	; Port C Input Pins bit 7
                                 
                                 
                                 ; ***** PORTD ************************
                                 ; PORTD - Port D Data Register
                                 .equ	PORTD0	= 0	; Port D Data Register bit 0
                                 .equ	PD0	= 0	; For compatibility
                                 .equ	PORTD1	= 1	; Port D Data Register bit 1
                                 .equ	PD1	= 1	; For compatibility
                                 .equ	PORTD2	= 2	; Port D Data Register bit 2
                                 .equ	PD2	= 2	; For compatibility
                                 .equ	PORTD3	= 3	; Port D Data Register bit 3
                                 .equ	PD3	= 3	; For compatibility
                                 .equ	PORTD4	= 4	; Port D Data Register bit 4
                                 .equ	PD4	= 4	; For compatibility
                                 .equ	PORTD5	= 5	; Port D Data Register bit 5
                                 .equ	PD5	= 5	; For compatibility
                                 .equ	PORTD6	= 6	; Port D Data Register bit 6
                                 .equ	PD6	= 6	; For compatibility
                                 .equ	PORTD7	= 7	; Port D Data Register bit 7
                                 .equ	PD7	= 7	; For compatibility
                                 
                                 ; DDRD - Port D Data Direction Register
                                 .equ	DDD0	= 0	; Port D Data Direction Register bit 0
                                 .equ	DDD1	= 1	; Port D Data Direction Register bit 1
                                 .equ	DDD2	= 2	; Port D Data Direction Register bit 2
                                 .equ	DDD3	= 3	; Port D Data Direction Register bit 3
                                 .equ	DDD4	= 4	; Port D Data Direction Register bit 4
                                 .equ	DDD5	= 5	; Port D Data Direction Register bit 5
                                 .equ	DDD6	= 6	; Port D Data Direction Register bit 6
                                 .equ	DDD7	= 7	; Port D Data Direction Register bit 7
                                 
                                 ; PIND - Port D Input Pins
                                 .equ	PIND0	= 0	; Port D Input Pins bit 0
                                 .equ	PIND1	= 1	; Port D Input Pins bit 1
                                 .equ	PIND2	= 2	; Port D Input Pins bit 2
                                 .equ	PIND3	= 3	; Port D Input Pins bit 3
                                 .equ	PIND4	= 4	; Port D Input Pins bit 4
                                 .equ	PIND5	= 5	; Port D Input Pins bit 5
                                 .equ	PIND6	= 6	; Port D Input Pins bit 6
                                 .equ	PIND7	= 7	; Port D Input Pins bit 7
                                 
                                 
                                 ; ***** PORTE ************************
                                 ; PORTE - Data Register, Port E
                                 .equ	PORTE0	= 0	; 
                                 .equ	PE0	= 0	; For compatibility
                                 .equ	PORTE1	= 1	; 
                                 .equ	PE1	= 1	; For compatibility
                                 .equ	PORTE2	= 2	; 
                                 .equ	PE2	= 2	; For compatibility
                                 .equ	PORTE3	= 3	; 
                                 .equ	PE3	= 3	; For compatibility
                                 .equ	PORTE4	= 4	; 
                                 .equ	PE4	= 4	; For compatibility
                                 .equ	PORTE5	= 5	; 
                                 .equ	PE5	= 5	; For compatibility
                                 .equ	PORTE6	= 6	; 
                                 .equ	PE6	= 6	; For compatibility
                                 .equ	PORTE7	= 7	; 
                                 .equ	PE7	= 7	; For compatibility
                                 
                                 ; DDRE - Data Direction Register, Port E
                                 .equ	DDE0	= 0	; 
                                 .equ	DDE1	= 1	; 
                                 .equ	DDE2	= 2	; 
                                 .equ	DDE3	= 3	; 
                                 .equ	DDE4	= 4	; 
                                 .equ	DDE5	= 5	; 
                                 .equ	DDE6	= 6	; 
                                 .equ	DDE7	= 7	; 
                                 
                                 ; PINE - Input Pins, Port E
                                 .equ	PINE0	= 0	; 
                                 .equ	PINE1	= 1	; 
                                 .equ	PINE2	= 2	; 
                                 .equ	PINE3	= 3	; 
                                 .equ	PINE4	= 4	; 
                                 .equ	PINE5	= 5	; 
                                 .equ	PINE6	= 6	; 
                                 .equ	PINE7	= 7	; 
                                 
                                 
                                 ; ***** PORTF ************************
                                 ; PORTF - Data Register, Port F
                                 .equ	PORTF0	= 0	; 
                                 .equ	PF0	= 0	; For compatibility
                                 .equ	PORTF1	= 1	; 
                                 .equ	PF1	= 1	; For compatibility
                                 .equ	PORTF2	= 2	; 
                                 .equ	PF2	= 2	; For compatibility
                                 .equ	PORTF3	= 3	; 
                                 .equ	PF3	= 3	; For compatibility
                                 .equ	PORTF4	= 4	; 
                                 .equ	PF4	= 4	; For compatibility
                                 .equ	PORTF5	= 5	; 
                                 .equ	PF5	= 5	; For compatibility
                                 .equ	PORTF6	= 6	; 
                                 .equ	PF6	= 6	; For compatibility
                                 .equ	PORTF7	= 7	; 
                                 .equ	PF7	= 7	; For compatibility
                                 
                                 ; DDRF - Data Direction Register, Port F
                                 .equ	DDF0	= 0	; 
                                 .equ	DDF1	= 1	; 
                                 .equ	DDF2	= 2	; 
                                 .equ	DDF3	= 3	; 
                                 .equ	DDF4	= 4	; 
                                 .equ	DDF5	= 5	; 
                                 .equ	DDF6	= 6	; 
                                 .equ	DDF7	= 7	; 
                                 
                                 ; PINF - Input Pins, Port F
                                 .equ	PINF0	= 0	; 
                                 .equ	PINF1	= 1	; 
                                 .equ	PINF2	= 2	; 
                                 .equ	PINF3	= 3	; 
                                 .equ	PINF4	= 4	; 
                                 .equ	PINF5	= 5	; 
                                 .equ	PINF6	= 6	; 
                                 .equ	PINF7	= 7	; 
                                 
                                 
                                 ; ***** PORTG ************************
                                 ; PORTG - Data Register, Port G
                                 .equ	PORTG0	= 0	; 
                                 .equ	PG0	= 0	; For compatibility
                                 .equ	PORTG1	= 1	; 
                                 .equ	PG1	= 1	; For compatibility
                                 .equ	PORTG2	= 2	; 
                                 .equ	PG2	= 2	; For compatibility
                                 .equ	PORTG3	= 3	; 
                                 .equ	PG3	= 3	; For compatibility
                                 .equ	PORTG4	= 4	; 
                                 .equ	PG4	= 4	; For compatibility
                                 
                                 ; DDRG - Data Direction Register, Port G
                                 .equ	DDG0	= 0	; 
                                 .equ	DDG1	= 1	; 
                                 .equ	DDG2	= 2	; 
                                 .equ	DDG3	= 3	; 
                                 .equ	DDG4	= 4	; 
                                 
                                 ; PING - Input Pins, Port G
                                 .equ	PING0	= 0	; 
                                 .equ	PING1	= 1	; 
                                 .equ	PING2	= 2	; 
                                 .equ	PING3	= 3	; 
                                 .equ	PING4	= 4	; 
                                 
                                 
                                 ; ***** TIMER_COUNTER_0 **************
                                 ; TCCR0 - Timer/Counter Control Register
                                 .equ	CS00	= 0	; Clock Select 0
                                 .equ	CS01	= 1	; Clock Select 1
                                 .equ	CS02	= 2	; Clock Select 2
                                 .equ	WGM01	= 3	; Waveform Generation Mode 1
                                 .equ	CTC0	= WGM01	; For compatibility
                                 .equ	COM00	= 4	; Compare match Output Mode 0
                                 .equ	COM01	= 5	; Compare Match Output Mode 1
                                 .equ	WGM00	= 6	; Waveform Generation Mode 0
                                 .equ	PWM0	= WGM00	; For compatibility
                                 .equ	FOC0	= 7	; Force Output Compare
                                 
                                 ; TCNT0 - Timer/Counter Register
                                 .equ	TCNT0_0	= 0	; 
                                 .equ	TCNT0_1	= 1	; 
                                 .equ	TCNT0_2	= 2	; 
                                 .equ	TCNT0_3	= 3	; 
                                 .equ	TCNT0_4	= 4	; 
                                 .equ	TCNT0_5	= 5	; 
                                 .equ	TCNT0_6	= 6	; 
                                 .equ	TCNT0_7	= 7	; 
                                 
                                 ; OCR0 - Output Compare Register
                                 .equ	OCR0_0	= 0	; 
                                 .equ	OCR0_1	= 1	; 
                                 .equ	OCR0_2	= 2	; 
                                 .equ	OCR0_3	= 3	; 
                                 .equ	OCR0_4	= 4	; 
                                 .equ	OCR0_5	= 5	; 
                                 .equ	OCR0_6	= 6	; 
                                 .equ	OCR0_7	= 7	; 
                                 
                                 ; ASSR - Asynchronus Status Register
                                 .equ	TCR0UB	= 0	; Timer/Counter Control Register 0 Update Busy
                                 .equ	OCR0UB	= 1	; Output Compare register 0 Busy
                                 .equ	TCN0UB	= 2	; Timer/Counter0 Update Busy
                                 .equ	AS0	= 3	; Asynchronus Timer/Counter 0
                                 
                                 ; TIMSK - Timer/Counter Interrupt Mask Register
                                 .equ	TOIE0	= 0	; Timer/Counter0 Overflow Interrupt Enable
                                 .equ	OCIE0	= 1	; Timer/Counter0 Output Compare Match Interrupt register
                                 
                                 ; TIFR - Timer/Counter Interrupt Flag register
                                 .equ	TOV0	= 0	; Timer/Counter0 Overflow Flag
                                 .equ	OCF0	= 1	; Output Compare Flag 0
                                 
                                 ; SFIOR - Special Function IO Register
                                 ;.equ	PSR0	= 1	; Prescaler Reset Timer/Counter0
                                 ;.equ	TSM	= 7	; Timer/Counter Synchronization Mode
                                 
                                 
                                 ; ***** TIMER_COUNTER_1 **************
                                 ; TIMSK - Timer/Counter Interrupt Mask Register
                                 .equ	TOIE1	= 2	; Timer/Counter1 Overflow Interrupt Enable
                                 .equ	OCIE1B	= 3	; Timer/Counter1 Output CompareB Match Interrupt Enable
                                 .equ	OCIE1A	= 4	; Timer/Counter1 Output CompareA Match Interrupt Enable
                                 .equ	TICIE1	= 5	; Timer/Counter1 Input Capture Interrupt Enable
                                 
                                 ; ETIMSK - Extended Timer/Counter Interrupt Mask Register
                                 .equ	OCIE1C	= 0	; Timer/Counter 1, Output Compare Match C Interrupt Enable
                                 
                                 ; TIFR - Timer/Counter Interrupt Flag register
                                 .equ	TOV1	= 2	; Timer/Counter1 Overflow Flag
                                 .equ	OCF1B	= 3	; Output Compare Flag 1B
                                 .equ	OCF1A	= 4	; Output Compare Flag 1A
                                 .equ	ICF1	= 5	; Input Capture Flag 1
                                 
                                 ; ETIFR - Extended Timer/Counter Interrupt Flag register
                                 .equ	OCF1C	= 0	; Timer/Counter 1, Output Compare C Match Flag
                                 
                                 ; SFIOR - Special Function IO Register
                                 ;.equ	PSR321	= 0	; Prescaler Reset, T/C3, T/C2, T/C1
                                 ;.equ	TSM	= 7	; Timer/Counter Synchronization Mode
                                 
                                 ; TCCR1A - Timer/Counter1 Control Register A
                                 .equ	WGM10	= 0	; Waveform Generation Mode Bit 0
                                 .equ	PWM10	= WGM10	; For compatibility
                                 .equ	WGM11	= 1	; Waveform Generation Mode Bit 1
                                 .equ	PWM11	= WGM11	; For compatibility
                                 .equ	COM1C0	= 2	; Compare Output Mode 1C, bit 0
                                 .equ	COM1C1	= 3	; Compare Output Mode 1C, bit 1
                                 .equ	COM1B0	= 4	; Compare Output Mode 1B, bit 0
                                 .equ	COM1B1	= 5	; Compare Output Mode 1B, bit 1
                                 .equ	COM1A0	= 6	; Compare Ouput Mode 1A, bit 0
                                 .equ	COM1A1	= 7	; Compare Output Mode 1A, bit 1
                                 
                                 ; TCCR1B - Timer/Counter1 Control Register B
                                 .equ	CS10	= 0	; Clock Select bit 0
                                 .equ	CS11	= 1	; Clock Select 1 bit 1
                                 .equ	CS12	= 2	; Clock Select1 bit 2
                                 .equ	WGM12	= 3	; Waveform Generation Mode
                                 .equ	CTC10	= WGM12	; For compatibility
                                 .equ	WGM13	= 4	; Waveform Generation Mode
                                 .equ	CTC11	= WGM13	; For compatibility
                                 .equ	ICES1	= 6	; Input Capture 1 Edge Select
                                 .equ	ICNC1	= 7	; Input Capture 1 Noise Canceler
                                 
                                 ; TCCR1C - Timer/Counter1 Control Register C
                                 .equ	FOC1C	= 5	; Force Output Compare for channel C
                                 .equ	FOC1B	= 6	; Force Output Compare for channel B
                                 .equ	FOC1A	= 7	; Force Output Compare for channel A
                                 
                                 
                                 ; ***** TIMER_COUNTER_2 **************
                                 ; TCCR2 - Timer/Counter Control Register
                                 .equ	CS20	= 0	; Clock Select
                                 .equ	CS21	= 1	; Clock Select
                                 .equ	CS22	= 2	; Clock Select
                                 .equ	WGM21	= 3	; Waveform Generation Mode
                                 .equ	CTC2	= WGM21	; For compatibility
                                 .equ	COM20	= 4	; Compare Match Output Mode
                                 .equ	COM21	= 5	; Compare Match Output Mode
                                 .equ	WGM20	= 6	; Wafeform Generation Mode
                                 .equ	PWM2	= WGM20	; For compatibility
                                 .equ	FOC2	= 7	; Force Output Compare
                                 
                                 ; TCNT2 - Timer/Counter Register
                                 .equ	TCNT2_0	= 0	; Timer/Counter Register Bit 0
                                 .equ	TCNT2_1	= 1	; Timer/Counter Register Bit 1
                                 .equ	TCNT2_2	= 2	; Timer/Counter Register Bit 2
                                 .equ	TCNT2_3	= 3	; Timer/Counter Register Bit 3
                                 .equ	TCNT2_4	= 4	; Timer/Counter Register Bit 4
                                 .equ	TCNT2_5	= 5	; Timer/Counter Register Bit 5
                                 .equ	TCNT2_6	= 6	; Timer/Counter Register Bit 6
                                 .equ	TCNT2_7	= 7	; Timer/Counter Register Bit 7
                                 
                                 ; OCR2 - Output Compare Register
                                 .equ	OCR2_0	= 0	; Output Compare Register Bit 0
                                 .equ	OCR2_1	= 1	; Output Compare Register Bit 1
                                 .equ	OCR2_2	= 2	; Output Compare Register Bit 2
                                 .equ	OCR2_3	= 3	; Output Compare Register Bit 3
                                 .equ	OCR2_4	= 4	; Output Compare Register Bit 4
                                 .equ	OCR2_5	= 5	; Output Compare Register Bit 5
                                 .equ	OCR2_6	= 6	; Output Compare Register Bit 6
                                 .equ	OCR2_7	= 7	; Output Compare Register Bit 7
                                 
                                 ; TIMSK - 
                                 .equ	TOIE2	= 6	; 
                                 .equ	OCIE2	= 7	; 
                                 
                                 ; TIFR - Timer/Counter Interrupt Flag Register
                                 .equ	TOV2	= 6	; Timer/Counter2 Overflow Flag
                                 .equ	OCF2	= 7	; Output Compare Flag 2
                                 
                                 
                                 ; ***** TIMER_COUNTER_3 **************
                                 ; ETIMSK - Extended Timer/Counter Interrupt Mask Register
                                 .equ	OCIE3C	= 1	; Timer/Counter3, Output Compare Match Interrupt Enable
                                 .equ	TOIE3	= 2	; Timer/Counter3 Overflow Interrupt Enable
                                 .equ	OCIE3B	= 3	; Timer/Counter3 Output CompareB Match Interrupt Enable
                                 .equ	OCIE3A	= 4	; Timer/Counter3 Output CompareA Match Interrupt Enable
                                 .equ	TICIE3	= 5	; Timer/Counter3 Input Capture Interrupt Enable
                                 
                                 ; ETIFR - Extended Timer/Counter Interrupt Flag register
                                 .equ	OCF3C	= 1	; Timer/Counter3 Output Compare C Match Flag
                                 .equ	TOV3	= 2	; Timer/Counter3 Overflow Flag
                                 .equ	OCF3B	= 3	; Output Compare Flag 1B
                                 .equ	OCF3A	= 4	; Output Compare Flag 1A
                                 .equ	ICF3	= 5	; Input Capture Flag 1
                                 
                                 ; SFIOR - Special Function IO Register
                                 ;.equ	PSR321	= 0	; Prescaler Reset, T/C3, T/C2, T/C1
                                 ;.equ	PSR1	= PSR321	; For compatibility
                                 ;.equ	PSR2	= PSR321	; For compatibility
                                 ;.equ	TSM	= 7	; Timer/Counter Synchronization Mode
                                 
                                 ; TCCR3A - Timer/Counter3 Control Register A
                                 .equ	WGM30	= 0	; Waveform Generation Mode Bit 0
                                 .equ	PWM30	= WGM30	; For compatibility
                                 .equ	WGM31	= 1	; Waveform Generation Mode Bit 1
                                 .equ	PWM31	= WGM31	; For compatibility
                                 .equ	COM3C0	= 2	; Compare Output Mode 3C, bit 0
                                 .equ	COM3C1	= 3	; Compare Output Mode 3C, bit 1
                                 .equ	COM3B0	= 4	; Compare Output Mode 3B, bit 0
                                 .equ	COM3B1	= 5	; Compare Output Mode 3B, bit 1
                                 .equ	COM3A0	= 6	; Comparet Ouput Mode 3A, bit 0
                                 .equ	COM3A1	= 7	; Compare Output Mode 3A, bit 1
                                 
                                 ; TCCR3B - Timer/Counter3 Control Register B
                                 .equ	CS30	= 0	; Clock Select 3 bit 0
                                 .equ	CS31	= 1	; Clock Select 3 bit 1
                                 .equ	CS32	= 2	; Clock Select3 bit 2
                                 .equ	WGM32	= 3	; Waveform Generation Mode
                                 .equ	CTC30	= WGM32	; For compatibility
                                 .equ	WGM33	= 4	; Waveform Generation Mode
                                 .equ	CTC31	= WGM33	; For compatibility
                                 .equ	ICES3	= 6	; Input Capture 3 Edge Select
                                 .equ	ICNC3	= 7	; Input Capture 3  Noise Canceler
                                 
                                 ; TCCR3C - Timer/Counter3 Control Register C
                                 .equ	FOC3C	= 5	; Force Output Compare for channel C
                                 .equ	FOC3B	= 6	; Force Output Compare for channel B
                                 .equ	FOC3A	= 7	; Force Output Compare for channel A
                                 
                                 ; TCNT3L - Timer/Counter3 Low Byte
                                 .equ	TCN3L0	= 0	; Timer/Counter 3 bit 0
                                 .equ	TCN3L1	= 1	; Timer/Counter 3 bit 1
                                 .equ	TCN3L2	= 2	; Timer/Counter 3 bit 2
                                 .equ	TCN3L3	= 3	; Timer/Counter 3 bit 3
                                 .equ	TCN3L4	= 4	; Timer/Counter 3 bit 4
                                 .equ	TCN3L5	= 5	; Timer/Counter 3 bit 5
                                 .equ	TCN3L6	= 6	; Timer/Counter 3 bit 6
                                 .equ	TCN3L7	= 7	; Timer/Counter 3 bit 7
                                 
                                 
                                 ; ***** WATCHDOG *********************
                                 ; WDTCR - Watchdog Timer Control Register
                                 .equ	WDTCSR	= WDTCR	; For compatibility
                                 .equ	WDP0	= 0	; Watch Dog Timer Prescaler bit 0
                                 .equ	WDP1	= 1	; Watch Dog Timer Prescaler bit 1
                                 .equ	WDP2	= 2	; Watch Dog Timer Prescaler bit 2
                                 .equ	WDE	= 3	; Watch Dog Enable
                                 .equ	WDCE	= 4	; Watchdog Change Enable
                                 .equ	WDTOE	= WDCE	; For compatibility
                                 
                                 
                                 ; ***** AD_CONVERTER *****************
                                 ; ADMUX - The ADC multiplexer Selection Register
                                 .equ	MUX0	= 0	; Analog Channel and Gain Selection Bits
                                 .equ	MUX1	= 1	; Analog Channel and Gain Selection Bits
                                 .equ	MUX2	= 2	; Analog Channel and Gain Selection Bits
                                 .equ	MUX3	= 3	; Analog Channel and Gain Selection Bits
                                 .equ	MUX4	= 4	; Analog Channel and Gain Selection Bits
                                 .equ	ADLAR	= 5	; Left Adjust Result
                                 .equ	REFS0	= 6	; Reference Selection Bit 0
                                 .equ	REFS1	= 7	; Reference Selection Bit 1
                                 
                                 ; ADCSRA - The ADC Control and Status register
                                 .equ	ADCSR	= ADCSRA	; For compatibility
                                 .equ	ADPS0	= 0	; ADC  Prescaler Select Bits
                                 .equ	ADPS1	= 1	; ADC  Prescaler Select Bits
                                 .equ	ADPS2	= 2	; ADC  Prescaler Select Bits
                                 .equ	ADIE	= 3	; ADC Interrupt Enable
                                 .equ	ADIF	= 4	; ADC Interrupt Flag
                                 .equ	ADFR	= 5	; ADC  Free Running Select
                                 .equ	ADSC	= 6	; ADC Start Conversion
                                 .equ	ADEN	= 7	; ADC Enable
                                 
                                 ; ADCH - ADC Data Register High Byte
                                 .equ	ADCH0	= 0	; ADC Data Register High Byte Bit 0
                                 .equ	ADCH1	= 1	; ADC Data Register High Byte Bit 1
                                 .equ	ADCH2	= 2	; ADC Data Register High Byte Bit 2
                                 .equ	ADCH3	= 3	; ADC Data Register High Byte Bit 3
                                 .equ	ADCH4	= 4	; ADC Data Register High Byte Bit 4
                                 .equ	ADCH5	= 5	; ADC Data Register High Byte Bit 5
                                 .equ	ADCH6	= 6	; ADC Data Register High Byte Bit 6
                                 .equ	ADCH7	= 7	; ADC Data Register High Byte Bit 7
                                 
                                 ; ADCL - ADC Data Register Low Byte
                                 .equ	ADCL0	= 0	; ADC Data Register Low Byte Bit 0
                                 .equ	ADCL1	= 1	; ADC Data Register Low Byte Bit 1
                                 .equ	ADCL2	= 2	; ADC Data Register Low Byte Bit 2
                                 .equ	ADCL3	= 3	; ADC Data Register Low Byte Bit 3
                                 .equ	ADCL4	= 4	; ADC Data Register Low Byte Bit 4
                                 .equ	ADCL5	= 5	; ADC Data Register Low Byte Bit 5
                                 .equ	ADCL6	= 6	; ADC Data Register Low Byte Bit 6
                                 .equ	ADCL7	= 7	; ADC Data Register Low Byte Bit 7
                                 
                                 
                                 
                                 ; ***** LOCKSBITS ********************************************************
                                 .equ	LB1	= 0	; Lock bit
                                 .equ	LB2	= 1	; Lock bit
                                 .equ	BLB01	= 2	; Boot Lock bit
                                 .equ	BLB02	= 3	; Boot Lock bit
                                 .equ	BLB11	= 4	; Boot lock bit
                                 .equ	BLB12	= 5	; Boot lock bit
                                 
                                 
                                 ; ***** FUSES ************************************************************
                                 ; LOW fuse bits
                                 .equ	CKSEL0	= 0	; Select Clock Source
                                 .equ	CKSEL1	= 1	; Select Clock Source
                                 .equ	CKSEL2	= 2	; Select Clock Source
                                 .equ	CKSEL3	= 3	; Select Clock Source
                                 .equ	SUT0	= 4	; Select start-up time
                                 .equ	SUT1	= 5	; Select start-up time
                                 .equ	BODEN	= 6	; Brown out detector enable
                                 .equ	BODLEVEL	= 7	; Brown out detector trigger level
                                 
                                 ; HIGH fuse bits
                                 .equ	BOOTRST	= 0	; Select Reset Vector
                                 .equ	BOOTSZ0	= 1	; Select Boot Size
                                 .equ	BOOTSZ1	= 2	; Select Boot Size
                                 .equ	EESAVE	= 3	; EEPROM memory is preserved through chip erase
                                 .equ	CKOPT	= 4	; Oscillator Options
                                 .equ	SPIEN	= 5	; Enable Serial programming and Data Downloading
                                 .equ	JTAGEN	= 6	; Enable JTAG
                                 .equ	OCDEN	= 7	; Enable OCD
                                 
                                 ; EXTENDED fuse bits
                                 .equ	WDTON	= 0	; Watchdog timer always on
                                 .equ	M103C	= 1	; ATmega103 compatibility mode
                                 
                                 
                                 
                                 ; ***** CPU REGISTER DEFINITIONS *****************************************
                                 .def	XH	= r27
                                 .def	XL	= r26
                                 .def	YH	= r29
                                 .def	YL	= r28
                                 .def	ZH	= r31
                                 .def	ZL	= r30
                                 
                                 
                                 
                                 ; ***** DATA MEMORY DECLARATIONS *****************************************
                                 .equ	FLASHEND	= 0xffff	; Note: Word address
                                 .equ	IOEND	= 0x00ff
                                 .equ	SRAM_START	= 0x0100
                                 .equ	SRAM_SIZE	= 4096
                                 .equ	RAMEND	= 0x10ff
                                 .equ	XRAMEND	= 0xffff
                                 .equ	E2END	= 0x0fff
                                 .equ	EEPROMEND	= 0x0fff
                                 .equ	EEADRBITS	= 12
                                 #pragma AVRPART MEMORY PROG_FLASH 131072
                                 #pragma AVRPART MEMORY EEPROM 4096
                                 #pragma AVRPART MEMORY INT_SRAM SIZE 4096
                                 #pragma AVRPART MEMORY INT_SRAM START_ADDR 0x100
                                 
                                 
                                 
                                 ; ***** BOOTLOADER DECLARATIONS ******************************************
                                 .equ	NRWW_START_ADDR	= 0xf000
                                 .equ	NRWW_STOP_ADDR	= 0xffff
                                 .equ	RWW_START_ADDR	= 0x0
                                 .equ	RWW_STOP_ADDR	= 0xefff
                                 .equ	PAGESIZE	= 128
                                 .equ	FIRSTBOOTSTART	= 0xfe00
                                 .equ	SECONDBOOTSTART	= 0xfc00
                                 .equ	THIRDBOOTSTART	= 0xf800
                                 .equ	FOURTHBOOTSTART	= 0xf000
                                 .equ	SMALLBOOTSTART	= FIRSTBOOTSTART
                                 .equ	LARGEBOOTSTART	= FOURTHBOOTSTART
                                 
                                 
                                 
                                 ; ***** INTERRUPT VECTORS ************************************************
                                 .equ	INT0addr	= 0x0002	; External Interrupt Request 0
                                 .equ	INT1addr	= 0x0004	; External Interrupt Request 1
                                 .equ	INT2addr	= 0x0006	; External Interrupt Request 2
                                 .equ	INT3addr	= 0x0008	; External Interrupt Request 3
                                 .equ	INT4addr	= 0x000a	; External Interrupt Request 4
                                 .equ	INT5addr	= 0x000c	; External Interrupt Request 5
                                 .equ	INT6addr	= 0x000e	; External Interrupt Request 6
                                 .equ	INT7addr	= 0x0010	; External Interrupt Request 7
                                 .equ	OC2addr	= 0x0012	; Timer/Counter2 Compare Match
                                 .equ	OVF2addr	= 0x0014	; Timer/Counter2 Overflow
                                 .equ	ICP1addr	= 0x0016	; Timer/Counter1 Capture Event
                                 .equ	OC1Aaddr	= 0x0018	; Timer/Counter1 Compare Match A
                                 .equ	OC1Baddr	= 0x001a	; Timer/Counter Compare Match B
                                 .equ	OVF1addr	= 0x001c	; Timer/Counter1 Overflow
                                 .equ	OC0addr	= 0x001e	; Timer/Counter0 Compare Match
                                 .equ	OVF0addr	= 0x0020	; Timer/Counter0 Overflow
                                 .equ	SPIaddr	= 0x0022	; SPI Serial Transfer Complete
                                 .equ	URXC0addr	= 0x0024	; USART0, Rx Complete
                                 .equ	UDRE0addr	= 0x0026	; USART0 Data Register Empty
                                 .equ	UTXC0addr	= 0x0028	; USART0, Tx Complete
                                 .equ	ADCCaddr	= 0x002a	; ADC Conversion Complete
                                 .equ	ERDYaddr	= 0x002c	; EEPROM Ready
                                 .equ	ACIaddr	= 0x002e	; Analog Comparator
                                 .equ	OC1Caddr	= 0x0030	; Timer/Counter1 Compare Match C
                                 .equ	ICP3addr	= 0x0032	; Timer/Counter3 Capture Event
                                 .equ	OC3Aaddr	= 0x0034	; Timer/Counter3 Compare Match A
                                 .equ	OC3Baddr	= 0x0036	; Timer/Counter3 Compare Match B
                                 .equ	OC3Caddr	= 0x0038	; Timer/Counter3 Compare Match C
                                 .equ	OVF3addr	= 0x003a	; Timer/Counter3 Overflow
                                 .equ	URXC1addr	= 0x003c	; USART1, Rx Complete
                                 .equ	UDRE1addr	= 0x003e	; USART1, Data Register Empty
                                 .equ	UTXC1addr	= 0x0040	; USART1, Tx Complete
                                 .equ	TWIaddr	= 0x0042	; 2-wire Serial Interface
                                 .equ	SPMRaddr	= 0x0044	; Store Program Memory Read
                                 
                                 .equ	INT_VECTORS_SIZE	= 70	; size in words
                                 
                                 #endif  /* _M128DEF_INC_ */
                                 
                                 ; ***** END OF FILE ******************************************************
                                 
                                 ; projectMatrix.asm
                                 ;
                                 ; Created: 08.05.2018 16:56:25
                                 ; Author : Niccol Stefanini & Gauzelin Vidovic
                                 
                                 .include "macros.asm"		; include macro definitions
                                 
                                 ; purpose library, general-purpose macros
                                 ; author (c) R.Holzer (adapted MICRO210/EE208 A.Schmid)
                                 
                                 ; ==============
                                 ; 	pointers
                                 ; ==============
                                 
                                 ; --- loading an immediate into a pointer XYZ,SP ---
                                 .macro 	LDIX	; sram
                                 	ldi	xl, low(@0)
                                 	ldi	xh,high(@0)
                                 	.endmacro	
                                 .macro 	LDIY	; sram	
                                 	ldi	yl, low(@0)
                                 	ldi	yh,high(@0)
                                 	.endmacro	
                                 .macro 	LDIZ	; sram
                                 	ldi	zl, low(@0)
                                 	ldi	zh,high(@0)
                                 	
                                 	.endmacro
                                 .macro	LDZD	; sram, reg	; sram+reg -> Z
                                 	mov	zl,@1
                                 	clr	zh
                                 	subi	zl, low(-@0)
                                 	sbci	zh,high(-@0)
                                 	.endmacro
                                 .macro	LDSP	; sram
                                 	ldi	r16, low(@0)
                                 	out	spl,r16
                                 	ldi	r16,high(@0)
                                 	out	sph,r16
                                 	.endmacro
                                 
                                 ; --- load/store SRAM addr into pointer XYZ ---	
                                 .macro 	LDSX	; sram
                                 	lds	xl,@0
                                 	lds	xh,@0+1
                                 	.endmacro
                                 .macro 	LDSY	; sram
                                 	lds	yl,@0
                                 	lds	yh,@0+1
                                 	.endmacro
                                 .macro 	LDSZ	; sram
                                 	lds	zl,@0
                                 	lds	zh,@0+1
                                 	.endmacro
                                 .macro 	STSX	; sram
                                 	sts	@0,  xl
                                 	sts	@0+1,xh
                                 	.endmacro	
                                 .macro 	STSY	; sram
                                 	sts	@0,  yl
                                 	sts	@0+1,yh
                                 	.endmacro
                                 .macro 	STSZ	; sram
                                 	sts	@0,  zl
                                 	sts	@0+1,zh
                                 	.endmacro	
                                 
                                 ; --- push/pop pointer XYZ ---
                                 .macro	PUSHX			; push X
                                 	push	xl
                                 	push	xh
                                 	.endmacro
                                 .macro	POPX			; pop X
                                 	pop	xh
                                 	pop	xl
                                 	.endmacro
                                 	
                                 .macro	PUSHY			; push Y
                                 	push	yl
                                 	push	yh
                                 	.endmacro
                                 .macro	POPY			; pop Y
                                 	pop	yh
                                 	pop	yl
                                 	.endmacro
                                 
                                 .macro	PUSHZ			; push Z
                                 	push	zl
                                 	push	zh
                                 	.endmacro
                                 .macro	POPZ			; pop Z
                                 	pop	zh
                                 	pop	zl
                                 	.endmacro
                                 
                                 ; --- multiply/divide Z ---	
                                 .macro	MUL2Z			; multiply Z by 2
                                 	lsl	zl
                                 	rol	zh
                                 	.endmacro
                                 .macro	DIV2Z			; divide Z by 2
                                 	lsr	zh
                                 	ror	zl
                                 	.endmacro
                                 
                                 ; --- add register to pointer XYZ ---	
                                 .macro	ADDX	;reg		; x <- y+reg
                                 	add	xl,@0
                                 	brcc	PC+2
                                 	subi	xh,-1		; add carry
                                 	.endmacro
                                 .macro	ADDY	;reg		; y <- y+reg
                                 	add	yl,@0
                                 	brcc	PC+2
                                 	subi	yh,-1		; add carry
                                 	.endmacro
                                 .macro	ADDZ	;reg		; z <- z+reg
                                 	add	zl,@0
                                 	brcc	PC+2
                                 	subi	zh,-1		; add carry
                                 	.endmacro
                                 
                                 ; ===================
                                 ; 	miscellaneous
                                 ; ===================
                                 
                                 ; --- output/store (regular I/O space) immediate value ---
                                 .macro	OUTI	; port,k	output immediate value to port
                                 	ldi	w,@1
                                 	out	@0,w
                                 	.endmacro
                                 
                                 ; --- output/store (extended I/O space) immediate value ---
                                 .macro OUTEI	; port,k    output immediate value to port
                                 	ldi	w,@1
                                 	sts	@0,w
                                 	.endmacro
                                 
                                 ; --- add immediate value ---
                                 .macro	ADDI
                                 	subi	@0,-@1
                                 	.endmacro
                                 .macro	ADCI
                                 	sbci	@0,-@1
                                 	.endmacro
                                 
                                 ; --- inc/dec with range limitation ---
                                 .macro	INC_LIM	; reg,limit
                                 	cpi	@0,@1
                                 	brlo	PC+3
                                 	ldi	@0,@1	
                                 	rjmp	PC+2
                                 	inc	@0
                                 	.endmacro
                                 
                                 .macro	DEC_LIM	; reg,limit
                                 	cpi	@0,@1
                                 	breq	PC+5
                                 	brlo	PC+3
                                 	dec	@0
                                 	rjmp	PC+2
                                 	ldi	@0,@1
                                 	.endmacro
                                 
                                 ; --- inc/dec with cyclic range ---
                                 .macro	CYCLIC	;reg,lo,hi					GOT MIDIFIED TO WORK WITH INCREMENTS BIGGER THAN ONE !		UNSIGNED NUMBERS ONLY
                                 	cpi		@0,@1
                                 	brsh	PC+2
                                 	ldi		@0,@2
                                 	cpi		@0,@2+1
                                 	brlo	PC+2
                                 	ldi		@0,@1
                                 .endmacro
                                 
                                 .macro	INC_CYC	; reg,low,high
                                 	cpi	@0,@2
                                 	brsh	_low	; reg>=high then reg=low
                                 	cpi	@0,@1
                                 	brlo	_low	; reg< low  then reg=low
                                 	inc	@0
                                 	rjmp	_done
                                 _low:	ldi	@0,@1
                                 _done:	
                                     .endmacro
                                 	
                                 .macro	DEC_CYC	; reg,low,high
                                 	cpi	@0,@1
                                 	breq	_high	; reg=low then reg=high
                                 	brlo	_high	; reg<low then reg=high
                                 	dec	@0	
                                 	cpi	@0,@2
                                 	brsh	_high	; reg>=high then high
                                 	rjmp	_done
                                 _high:	ldi	@0,@2
                                 _done:	
                                 	.endmacro
                                 
                                 .macro	INCDEC	;port,b1,b2,reg,low,high
                                 	sbic	@0,@1
                                 	rjmp	PC+6
                                 
                                 	cpi	@3,@5
                                 	brlo	PC+3
                                 	ldi	@3,@4	
                                 	rjmp	PC+2
                                 	inc	@3
                                 
                                 	sbic	@0,@2
                                 	rjmp	PC+7
                                 	
                                 	cpi	@3,@4
                                 	breq	PC+5
                                 	brlo	PC+3
                                 	dec	@3
                                 	rjmp	PC+2
                                 	ldi	@3,@5
                                 	.endmacro		
                                 
                                 ; --- wait loops ---
                                 ; wait 10...196608 cycles
                                 .macro	WAIT_C	; k
                                 	ldi	w,  low((@0-7)/3)
                                 	mov	u,w			; u=LSB
                                 	ldi	w,high((@0-7)/3)+1	; w=MSB
                                 	dec	u
                                 	brne	PC-1
                                 	dec	u
                                 	dec	w
                                 	brne	PC-4
                                 	.endmacro
                                 
                                 ; wait micro-seconds (us)
                                 ; us = x*3*1000'000/clock)	==> x=us*clock/3000'000
                                 .macro	WAIT_US ; k
                                 	ldi	w, low((clock/1000*@0/3000)-1)
                                 	mov	u,w
                                 	ldi	w,high((clock/1000*@0/3000)-1)+1 ; set up: 3 cyles
                                 	dec	u
                                 	brne	PC-1		; inner loop: 3 cycles
                                 	dec	u		; adjustment for outer loop
                                 	dec	w
                                 	brne	PC-4
                                 	.endmacro
                                 
                                 ; wait mili-seconds (ms)
                                 .macro	WAIT_MS ; k
                                 	ldi	w, low(@0)
                                 	mov	u,w		; u = LSB	
                                 	ldi	w,high(@0)+1	; w = MSB
                                 wait_ms:
                                 	push	w		; wait 1000 usec
                                 	push	u
                                 	ldi	w, low((clock/3000)-5)	
                                 	mov	u,w
                                 	ldi	w,high((clock/3000)-5)+1
                                 	dec	u
                                 	brne	PC-1		; inner loop: 3 cycles
                                 	dec	u		; adjustment for outer loop
                                 	dec	w
                                 	brne	PC-4
                                 	pop	u
                                 	pop	w
                                 	
                                 	dec	u
                                 	brne	wait_ms
                                 	dec	w
                                 	brne	wait_ms
                                 	.endmacro
                                 
                                 ; --- conditional jumps/calls ---
                                 .macro	JC0			; jump if carry=0
                                 	brcs	PC+2	
                                 	rjmp	@0
                                 	.endmacro
                                 .macro	JC1			; jump if carry=1
                                 	brcc	PC+2	
                                 	rjmp	@0
                                 	.endmacro
                                 
                                 .macro	JK	; reg,k,addr	; jump if reg=k
                                 	cpi	@0,@1
                                 	breq	@2
                                 	.endmacro
                                 .macro	_JK	; reg,k,addr	; jump if reg=k
                                 	cpi	@0,@1
                                 	brne	PC+2
                                 	rjmp	@2
                                 	.endmacro	
                                 .macro	JNK	; reg,k,addr	; jump if not(reg=k)
                                 	cpi	@0,@1
                                 	brne	@2
                                 	.endmacro 
                                 
                                 .macro	CK	; reg,k,addr	; call if reg=k
                                 	cpi	@0,@1
                                 	brne	PC+2
                                 	rcall	@2
                                 	.endmacro
                                 .macro	CNK	; reg,k,addr	; call if not(reg=k)
                                 	cpi	@0,@1
                                 	breq	PC+2
                                 	rcall	@2
                                 	.endmacro 
                                 
                                 .macro	JSK	; sram,k,addr	; jump if sram=k
                                 	lds	w,@0
                                 	cpi	w,@1
                                 	breq	@2
                                 	.endmacro 
                                 .macro	JSNK	; sram,k,addr	; jump if not(sram=k)
                                 	lds	w,@0
                                 	cpi	w,@1
                                 	brne	@2
                                 	.endmacro
                                 
                                 ; --- loops ---
                                 .macro	DJNZ	; reg,addr	; decr and jump if not zero
                                 	dec	@0
                                 	brne	@1
                                 	.endmacro
                                 .macro	DJNK	; reg,k,addr	; decr and jump if not k
                                 	dec	@0
                                 	cpi	@0,@1
                                 	brne	@2
                                 	.endmacro
                                 
                                 .macro	IJNZ	; reg,addr	; inc and jump if not zero
                                 	inc	@0
                                 	brne	@1
                                 	.endmacro
                                 .macro	IJNK	; reg,k,addr	; inc and jump if not k
                                 	inc	@0
                                 	cpi	@0,@1
                                 	brne	@2
                                 	.endmacro
                                 .macro	_IJNK	; reg,k,addr	; inc and jump if not k
                                 	inc	@0
                                 	ldi	w,@1
                                 	cp	@0,w
                                 	brne	@2
                                 	.endmacro
                                 
                                 .macro	ISJNK	; sram,k,addr	; inc sram and jump if not k
                                 	lds	w,@0
                                 	inc	w
                                 	sts	@0,w
                                 	cpi	w,@1
                                 	brne	@2
                                 	.endmacro
                                 .macro	_ISJNK	; sram,k,addr	; inc sram and jump if not k
                                 	lds	w,@0
                                 	inc	w
                                 	sts	@0,w
                                 	cpi	w,@1
                                 	breq	PC+2	
                                 	rjmp	@2
                                 	.endmacro
                                 
                                 .macro	DSJNK	; sram,k,addr	; dec sram and jump if not k
                                 	lds	w,@0
                                 	dec	w
                                 	sts	@0,w
                                 	cpi	w,@1
                                 	brne	@2
                                 	.endmacro
                                 
                                 ; --- table lookup ---
                                 .macro	LOOKUP	;reg, index,tbl
                                 	push	ZL
                                 	push	ZH
                                 	mov	zl,@1		; move index into z
                                 	clr	zh
                                 	subi	zl, low(-2*@2)	; add base address of table
                                 	sbci	zh,high(-2*@2)	
                                 	lpm			; load program memory (into r0)
                                 	mov	@0,r0
                                 	pop	ZH
                                 	pop	ZL
                                 	.endmacro
                                 
                                 .macro	LOOKUP2	;r1,r0, index,tbl
                                 	mov	zl,@2		; move index into z
                                 	clr	zh
                                 	lsl	zl		; multiply by 2
                                 	rol	zh
                                 	subi	zl, low(-2*@3)	; add base address of table
                                 	sbci	zh,high(-2*@3)
                                 	lpm			; get LSB byte
                                 	mov	w,r0		; temporary store LSB in w
                                 	adiw	zl,1		; increment Z
                                 	lpm			; get MSB byte
                                 	mov	@0,r0		; mov MSB to res1
                                 	mov	@1,w		; mov LSB to res0
                                 	.endmacro
                                 
                                 .macro	LOOKUP4	;r3,r2,r1,r0, index,tbl
                                 	mov	zl,@4		; move index into z
                                 	clr	zh
                                 	lsl	zl		; multiply by 2
                                 	rol	zh
                                 	lsl	zl		; multiply by 2
                                 	rol	zh	
                                 	subi	zl, low(-2*@5)	; add base address of table
                                 	sbci	zh,high(-2*@5)
                                 	lpm
                                 	mov	@1,r0		; load high word LSB
                                 	adiw	zl,1
                                 	lpm
                                 	mov	@0,r0		; load high word MSB
                                 	adiw	zl,1
                                 	lpm
                                 	mov	@3,r0		; load low word LSB		
                                 	adiw	zl,1
                                 	lpm
                                 	mov	@2,r0		; load low word MSB
                                 	.endmacro
                                 
                                 .macro	LOOKDOWN ;reg,index,tbl
                                 	ldi	ZL, low(2*@2)	; load table address
                                 	ldi	ZH,high(2*@2)
                                 	clr	@1
                                 loop:	lpm
                                 	cp	r0,@0
                                 	breq	found
                                 	inc	@1
                                 	adiw	ZL,1
                                 	tst	r0
                                 	breq	notfound
                                 	rjmp	loop
                                 notfound:
                                 	ldi	@1,-1
                                 found:	
                                 	.endmacro
                                 
                                 ; --- branch table ---
                                 .macro	C_TBL	; reg,tbl
                                 	ldi		ZL, low(2*@1)
                                 	ldi		ZH,high(2*@1)
                                 	lsl		@0
                                 	add		ZL,@0
                                 	brcc	PC+2
                                 	inc		ZH
                                 	lpm
                                 	push	r0
                                 	lpm
                                 	mov		zh,r0
                                 	pop		zl
                                 	icall
                                 	.endmacro
                                 .macro	J_TBL	; reg,tbl	
                                 	ldi	ZL, low(2*@1)
                                 	ldi	ZH,high(2*@1)
                                 	lsl	@0
                                 	add	ZL,@0
                                 	brcc	PC+2
                                 	inc	ZH
                                 	lpm
                                 	push	r0
                                 	lpm
                                 	mov	zh,r0
                                 	pop	zl	
                                 	ijmp
                                 	.endmacro
                                 
                                 .macro	BRANCH	; reg		; branching using the stack
                                 	ldi	w, low(tbl)
                                 	add	w,@0
                                 	push	w
                                 	ldi	w,high(tbl)
                                 	brcc	PC+2
                                 	inc	w
                                 	push	w
                                 	ret
                                 tbl:
                                 	.endmacro	
                                 
                                 ; --- multiply/division ---
                                 .macro	DIV2	; reg
                                 	lsr	@0
                                 	.endmacro
                                 .macro	DIV4	; reg
                                 	lsr	@0
                                 	lsr	@0
                                 	.endmacro	
                                 .macro	DIV8	; reg
                                 	lsr	@0
                                 	lsr	@0
                                 	lsr	@0
                                 	.endmacro
                                 	
                                 .macro	MUL2	; reg
                                 	lsl	@0
                                 	.endmacro
                                 .macro	MUL4	; reg
                                 	lsl	@0
                                 	lsl	@0
                                 	.endmacro
                                 .macro	MUL8	; reg
                                 	lsl	@0
                                 	lsl	@0
                                 	lsl	@0
                                 	.endmacro
                                 
                                 ; ====================================
                                 ; 	extending existing instructios
                                 ; ====================================
                                 
                                 ; --- immediate ops with r0..r15 ---
                                 .macro	_ADDI
                                 	ldi	w,@1
                                 	add	@0,w
                                 	.endmacro
                                 .macro	_ADCI
                                 	ldi	w,@1
                                 	adc	@0,w
                                 	.endmacro
                                 .macro	_SUBI
                                 	ldi	w,@1
                                 	sub	@0,w
                                 	.endmacro
                                 .macro	_SBCI
                                 	ldi	w,@1
                                 	sbc	@0,w
                                 	.endmacro
                                 .macro	_ANDI
                                 	ldi	w,@1
                                 	and	@0,w
                                 	.endmacro
                                 .macro	_ORI
                                 	ldi	w,@1
                                 	or	@0,w
                                 	.endmacro
                                 .macro	_EORI
                                 	ldi	w,@1
                                 	eor	@0,w
                                 	.endmacro
                                 .macro	_SBR
                                 	ldi	w,@1
                                 	or	@0,w
                                 	.endmacro
                                 .macro	_CBR
                                 	ldi	w,~@1
                                 	and	@0,w
                                 	.endmacro
                                 .macro	_CPI
                                 	ldi	w,@1
                                 	cp	@0,w
                                 	.endmacro
                                 .macro	_LDI
                                 	ldi	w,@1
                                 	mov	@0,w
                                 	.endmacro
                                 
                                 ; --- bit access for port p32..p63 ---
                                 .macro	_SBI
                                 	in	w,@0
                                 	ori	w,1<<@1
                                 	out	@0,w
                                 	.endmacro
                                 .macro	_CBI
                                 	in	w,@0
                                 	andi	w,~(1<<@1)
                                 	out	@0,w
                                 	.endmacro
                                 	
                                 ; --- extending branch distance to +/-2k ---
                                 .macro	_BREQ
                                 	brne	PC+2
                                 	rjmp	@0
                                 	.endmacro
                                 .macro	_BRNE
                                 	breq	PC+2
                                 	rjmp	@0
                                 	.endmacro
                                 .macro	_BRCS
                                 	brcc	PC+2
                                 	rjmp	@0
                                 	.endmacro
                                 .macro	_BRCC
                                 	brcs	PC+2
                                 	rjmp	@0
                                 	.endmacro
                                 .macro	_BRSH
                                 	brlo	PC+2
                                 	rjmp	@0
                                 	.endmacro
                                 .macro	_BRLO
                                 	brsh	PC+2
                                 	rjmp	@0
                                 	.endmacro
                                 .macro	_BRMI
                                 	brpl	PC+2
                                 	rjmp	@0
                                 	.endmacro
                                 .macro	_BRPL
                                 	brmi	PC+2
                                 	rjmp	@0
                                 	.endmacro
                                 .macro	_BRGE
                                 	brlt	PC+2
                                 	rjmp	@0
                                 	.endmacro
                                 .macro	_BRLT
                                 	brge	PC+2
                                 	rjmp	@0
                                 	.endmacro
                                 .macro	_BRHS
                                 	brhc	PC+2
                                 	rjmp	@0
                                 	.endmacro
                                 .macro	_BRHC
                                 	brhs	PC+2
                                 	rjmp	@0
                                 	.endmacro
                                 .macro	_BRTS
                                 	brtc	PC+2
                                 	rjmp	@0
                                 	.endmacro
                                 .macro	_BRTC
                                 	brts	PC+2
                                 	rjmp	@0
                                 	.endmacro
                                 .macro	_BRVS
                                 	brvc	PC+2
                                 	rjmp	@0
                                 	.endmacro
                                 .macro	_BRVC
                                 	brvs	PC+2
                                 	rjmp	@0
                                 	.endmacro
                                 .macro	_BRIE
                                 	brid	PC+2
                                 	rjmp	@0
                                 	.endmacro
                                 .macro	_BRID
                                 	brie	PC+2
                                 	rjmp	@0
                                 	.endmacro
                                 
                                 ; ====================
                                 ; 	bit operations
                                 ; ====================
                                 
                                 ; --- moving bits ---
                                 .macro	MOVB	; reg1,b1, reg2,b2	; reg1,bit1 <- reg2,bit2
                                 	bst	@2,@3
                                 	bld	@0,@1
                                 	.endmacro
                                 .macro	OUTB	; port1,b1, reg2,b2	; port1,bit1 <- reg2,bit2
                                 	sbrs	@2,@3
                                 	cbi	@0,@1
                                 	sbrc	@2,@3
                                 	sbi	@0,@1
                                 	.endmacro
                                 .macro	INB	; reg1,b1, port2,b2	; reg1,bit1 <- port2,bit2
                                 	sbis	@2,@3
                                 	cbr	@0,1<<@1
                                 	sbic	@2,@3
                                 	sbr	@0,1<<@1
                                 	.endmacro
                                 
                                 .macro	Z2C				; zero to carry
                                 	sec
                                 	breq	PC+2	; (Z=1)
                                 	clc
                                 	.endmacro
                                 .macro	Z2INVC				; zero to inverse carry
                                 	sec
                                 	brne	PC+2	; (Z=0)
                                 	clc
                                 	.endmacro
                                 
                                 .macro	C2Z				; carry to zero
                                 	sez
                                 	brcs	PC+2	; (C=1)
                                 	clz
                                 	.endmacro
                                 
                                 .macro	B2C	; reg,b			; bit to carry
                                 	sbrc	@0,@1
                                 	sec
                                 	sbrs	@0,@1
                                 	clc
                                 	.endmacro
                                 .macro	C2B	; reg,b			; carry to bit
                                 	brcc	PC+2
                                 	sbr	@0,(1<<@1)
                                 	brcs	PC+2
                                 	cbr	@0,(1<<@1)
                                 	.endmacro
                                 .macro	P2C	; port,b		; port to carry
                                 	sbic	@0,@1
                                 	sec
                                 	sbis	@0,@1
                                 	clc
                                 	.endmacro
                                 .macro	C2P	; port,b		; carry to port
                                 	brcc	PC+2
                                 	sbi	@0,@1
                                 	brcs	PC+2
                                 	cbi	@0,@1
                                 	.endmacro
                                 
                                 ; --- inverting bits ---
                                 .macro	INVB	; reg,bit		; inverse reg,bit
                                 	ldi	w,(1<<@1)
                                 	eor	@0,w
                                 	.endmacro
                                 .macro	INVP	; port,bit		; inverse port,bit	
                                 	sbis	@0,@1
                                 	rjmp	PC+3
                                 	cbi	@0,@1
                                 	rjmp	PC+2
                                 	sbi	@0,@1
                                 	.endmacro
                                 .macro	INVC				; inverse carry	
                                 	brcs	PC+3
                                 	sec
                                 	rjmp	PC+2
                                 	clc
                                 	.endmacro
                                 
                                 ; --- setting a single bit ---
                                 .macro	SETBIT	; reg(0..7)
                                 ; in	reg (0..7)
                                 ; out	reg with bit (0..7) set to 1.
                                 ; 0=00000001
                                 ; 1=00000010
                                 ; ...
                                 ; 7=10000000
                                 	mov	w,@0
                                 	clr	@0
                                 	inc	@0
                                 	andi	w,0b111	
                                 	breq	PC+4
                                 	lsl	@0
                                 	dec	w
                                 	brne	PC-2
                                 	.endmacro
                                 
                                 ; --- logical operations with masks ---
                                 .macro	MOVMSK	; reg1,reg2,mask	; reg1 <- reg2 (mask)
                                 	ldi	w,~@2	
                                 	and	@0,w
                                 	ldi	w,@2
                                 	and	@1,w	
                                 	or	@0,@1
                                 	.endmacro	
                                 .macro	ANDMSK	; reg1,reg2,mask	; reg1 <- ret 1 AND reg2 (mask)		
                                 	mov	w,@1
                                 	ori	w,~@2
                                 	and	@0,w
                                 	.endmacro	
                                 .macro	ORMSK	; reg1,reg2,mask	; reg1 <- ret 1 AND reg2 (mask)		
                                 	mov	w,@1
                                 	andi	w,@2
                                 	or	@0,w
                                 	.endmacro
                                 	
                                 ; --- logical operations on bits ---
                                 .macro	ANDB	; r1,b1, r2,b2, r3,b3	; reg1,b1 <- reg2,b2 AND reg3,b3
                                 	set
                                 	sbrs	@4,@5	
                                 	clt
                                 	sbrs	@2,@3	
                                 	clt
                                 	bld	@0,@1
                                 	.endmacro
                                 .macro	ORB	; r1,b1, r2,b2, r3,b3	; reg1.b1 <- reg2.b2 OR reg3.b3
                                 	clt
                                 	sbrc	@4,@5	
                                 	set
                                 	sbrc	@2,@3	
                                 	set
                                 	bld	@0,@1
                                 	.endmacro
                                 .macro	EORB	; r1,b1, r2,b2, r3,b3	; reg1.b1 <- reg2.b2 XOR reg3.b3
                                 	sbrc	@4,@5
                                 	rjmp	f1
                                 f0:	bst	@2,@3	
                                 	rjmp	PC+4
                                 f1:	set
                                 	sbrc	@0,@1
                                 	clt
                                 	bld	@0,@0	
                                 	.endmacro
                                 	
                                 ; --- operations based on register bits ---
                                 .macro	FB0	; reg,bit		; bit=0
                                 	cbr	@0,1<<@1
                                 	.endmacro
                                 .macro	FB1	; reg,bit		; bit=1
                                 	sbr	@0,1<<@1
                                 	.endmacro
                                 .macro	_FB0	; reg,bit		; bit=0
                                 	ldi	w,~(1<<@1)
                                 	and	@0,w
                                 	.endmacro
                                 .macro	_FB1	; reg,bit		; bit=1
                                 	ldi	w,1<<@1
                                 	or	@0,w
                                 	.endmacro
                                 .macro	SB0	; reg,bit,addr		; skip if bit=0
                                 	sbrc	@0,@1
                                 	.endmacro
                                 .macro	SB1	; reg,bit,addr		; skip if bit=1
                                 	sbrs	@0,@1
                                 	.endmacro
                                 .macro	JB0	; reg,bit,addr		; jump if bit=0
                                 	sbrs	@0,@1
                                 	rjmp	@2
                                 	.endmacro
                                 .macro	JB1	; reg,bit,addr		; jump if bit=1
                                 	sbrc	@0,@1
                                 	rjmp	@2
                                 	.endmacro
                                 .macro	CB0	; reg,bit,addr		; call if bit=0
                                 	sbrs	@0,@1
                                 	rcall	@2
                                 	.endmacro
                                 .macro	CB1	; reg,bit,addr		; call if bit=1
                                 	sbrc	@0,@1
                                 	rcall	@2
                                 	.endmacro
                                 .macro	WB0	; reg,bit		; wait if bit=0
                                 	sbrs	@0,@1
                                 	rjmp	PC-1
                                 	.endmacro
                                 .macro	WB1	; reg,bit		; wait if bit=1
                                 	sbrc	@0,@1
                                 	rjmp	PC-1
                                 	.endmacro
                                 .macro	RB0	; reg,bit		; return if bit=0
                                 	sbrs	@0,@1
                                 	ret
                                 	.endmacro
                                 .macro	RB1	; reg,bit		; return if bit=1
                                 	sbrc	@0,@1
                                 	ret
                                 	.endmacro
                                 
                                 ; wait if bit=0 with timeout
                                 ; if timeout (in units of 5 cyc) then jump to addr
                                 .macro	WB0T	; reg,bit,timeout,addr
                                 	ldi	w,@2+1
                                 	dec	w	; 1 cyc
                                 	breq	@3	; 1 cyc
                                 	sbrs	@0,@1	; 1 cyc
                                 	rjmp	PC-3	; 2 cyc = 5 cycles
                                 	.endmacro
                                 
                                 ; wait if bit=1 with timeout
                                 ; if timeout (in units of 5 cyc) then jump to addr	
                                 .macro	WB1T	; reg,bit,timeout,addr
                                 	ldi	w,@2+1
                                 	dec	w	; 1 cyc
                                 	breq	@3	; 1 cyc
                                 	sbrc	@0,@1	; 1 cyc
                                 	rjmp	PC-3	; 2 cyc = 5 cycles
                                 	.endmacro	
                                 	
                                 ; --- operations based on port bits ---
                                 .macro	P0	; port,bit		; port=0
                                 	cbi	@0,@1
                                 	.endmacro
                                 .macro	P1	; port,bit		; port=1
                                 	sbi	@0,@1
                                 	.endmacro
                                 .macro	SP0	; port,bit		; skip if port=0
                                 	sbic	@0,@1
                                 	.endmacro
                                 .macro	SP1	; port,bit		; skip if port=1
                                 	sbis	@0,@1
                                 	.endmacro
                                 .macro	JP0	; port,bit,addr		; jump if port=0
                                 	sbis	@0,@1
                                 	rjmp	@2
                                 	.endmacro
                                 .macro	JP1	; port,bit,addr		; jump if port=1
                                 	sbic	@0,@1
                                 	rjmp	@2
                                 	.endmacro
                                 .macro	CP0	; port,bit,addr		; call if port=0
                                 	sbis	@0,@1
                                 	rcall	@2
                                 	.endmacro
                                 .macro	CP1	; port,bit,addr		; call if port=1
                                 	sbic	@0,@1
                                 	rcall	@2
                                 	.endmacro
                                 .macro	WP0	; port,bit		; wait if port=0
                                 	sbis	@0,@1
                                 	rjmp	PC-1
                                 	.endmacro
                                 .macro	WP1	; port,bit		; wait if port=1
                                 	sbic	@0,@1
                                 	rjmp	PC-1
                                 	.endmacro
                                 .macro	RP0	; port,bit		; return if port=0
                                 	sbis	@0,@1
                                 	ret
                                 	.endmacro
                                 .macro	RP1	; port,bit		; return if port=1
                                 	sbic	@0,@1
                                 	ret
                                 	.endmacro
                                 
                                 ; wait if port=0 with timeout
                                 ; if timeout (in units of 5 cyc) then jump to addr
                                 .macro	WP0T	; port,bit,timeout,addr
                                 	ldi	w,@2+1
                                 	dec	w	; 1 cyc
                                 	breq	@3	; 1 cyc
                                 	sbis	@0,@1	; 1 cyc
                                 	rjmp	PC-3	; 2 cyc = 5 cycles
                                 	.endmacro
                                 
                                 ; wait if port=1 with timeout
                                 ; if timeout (in units of 5 cyc) then jump to addr	
                                 .macro	WP1T	; port,bit,timeout,addr
                                 	ldi	w,@2+1
                                 	dec	w	; 1 cyc
                                 	breq	@3	; 1 cyc
                                 	sbic	@0,@1	; 1 cyc
                                 	rjmp	PC-3	; 2 cyc = 5 cycles
                                 	.endmacro	
                                 
                                 ; ===========================
                                 ; 	multi-byte operations
                                 ; ===========================
                                 
                                 .macro	SWAP4			; swap 2 variables
                                 	mov	w ,@0
                                 	mov	@0,@4
                                 	mov	@4,w
                                 	mov	w ,@1
                                 	mov	@1,@5
                                 	mov	@5,w
                                 	mov	w ,@2
                                 	mov	@2,@6
                                 	mov	@6,w
                                 	mov	w ,@3
                                 	mov	@3,@7
                                 	mov	@7,w
                                 	.endmacro
                                 .macro	SWAP3
                                 	mov	w ,@0
                                 	mov	@0,@3
                                 	mov	@3,w
                                 	mov	w ,@1
                                 	mov	@1,@4
                                 	mov	@4,w
                                 	mov	w ,@2
                                 	mov	@2,@5
                                 	mov	@5,w
                                 	.endmacro
                                 .macro	SWAP2
                                 	mov	w ,@0
                                 	mov	@0,@2
                                 	mov	@2,w
                                 	mov	w ,@1
                                 	mov	@1,@3
                                 	mov	@3,w
                                 	.endmacro
                                 .macro	SWAP1
                                 	mov	w ,@0
                                 	mov	@0,@1
                                 	mov	@1,w
                                 	.endmacro
                                 
                                 .macro	LDX4	;r..r0		; load from (x+)
                                 	ld	@3,x+
                                 	ld	@2,x+	
                                 	ld	@1,x+
                                 	ld	@0,x+
                                 	.endmacro
                                 .macro	LDX3	;r..r0
                                 	ld	@2,x+	
                                 	ld	@1,x+
                                 	ld	@0,x+
                                 	.endmacro
                                 .macro	LDX2	;r..r0	
                                 	ld	@1,x+
                                 	ld	@0,x+
                                 	.endmacro
                                 	
                                 .macro	LDY4	;r..r0		; load from (y+)
                                 	ld	@3,y+
                                 	ld	@2,y+	
                                 	ld	@1,y+
                                 	ld	@0,y+
                                 	.endmacro
                                 .macro	LDY3	;r..r0
                                 	ld	@2,y+	
                                 	ld	@1,y+
                                 	ld	@0,y+
                                 	.endmacro
                                 .macro	LDY2	;r..r0	
                                 	ld	@1,y+
                                 	ld	@0,y+
                                 	.endmacro
                                 
                                 .macro	LDZ4	;r..r0		; load from (z+)
                                 	ld	@3,z+
                                 	ld	@2,z+	
                                 	ld	@1,z+
                                 	ld	@0,z+
                                 	.endmacro
                                 .macro	LDZ3	;r..r0
                                 	ld	@2,z+	
                                 	ld	@1,z+
                                 	ld	@0,z+
                                 	.endmacro
                                 .macro	LDZ2	;r..r0
                                 	ld	@1,z+
                                 	ld	@0,z+
                                 	.endmacro
                                 
                                 .macro	STX4	;r..r0		; store to (x+)
                                 	st	x+,@3
                                 	st	x+,@2	
                                 	st	x+,@1
                                 	st	x+,@0
                                 	.endmacro
                                 .macro	STX3	;r..r0
                                 	st	x+,@2	
                                 	st	x+,@1
                                 	st	x+,@0
                                 	.endmacro
                                 .macro	STX2	;r..r0
                                 	st	x+,@1
                                 	st	x+,@0
                                 	.endmacro
                                 	
                                 .macro	STY4	;r..r0		; store to (y+)
                                 	st	y+,@3
                                 	st	y+,@2	
                                 	st	y+,@1
                                 	st	y+,@0
                                 	.endmacro
                                 .macro	STY3	;r..r0
                                 	st	y+,@2	
                                 	st	y+,@1
                                 	st	y+,@0
                                 	.endmacro
                                 .macro	STY2	;r..r0	
                                 	st	y+,@1
                                 	st	y+,@0
                                 	.endmacro
                                 	
                                 .macro	STZ4	;r..r0		; store to (z+)
                                 	st	z+,@3
                                 	st	z+,@2	
                                 	st	z+,@1
                                 	st	z+,@0
                                 	.endmacro	
                                 .macro	STZ3	;r..r0
                                 	st	z+,@2	
                                 	st	z+,@1
                                 	st	z+,@0
                                 	.endmacro	
                                 .macro	STZ2	;r..r0	
                                 	st	z+,@1
                                 	st	z+,@0
                                 	.endmacro	
                                 	
                                 .macro	STI4	;addr,k		; store immediate
                                 	ldi	w,  low(@1)
                                 	sts	@0+0,w
                                 	ldi	w, high(@1)
                                 	sts	@0+1,w
                                 	ldi	w,byte3(@1)
                                 	sts	@0+2,w
                                 	ldi	w,byte4(@1)
                                 	sts	@0+3,w	
                                 	.endmacro	
                                 .macro	STI3	;addr,k
                                 	ldi	w,  low(@1)
                                 	sts	@0+0,w
                                 	ldi	w, high(@1)
                                 	sts	@0+1,w
                                 	ldi	w,byte3(@1)
                                 	sts	@0+2,w
                                 	.endmacro	
                                 .macro	STI2	;addr,k
                                 	ldi	w,  low(@1)
                                 	sts	@0+0,w
                                 	ldi	w, high(@1)
                                 	sts	@0+1,w
                                 	.endmacro
                                 .macro	STI	;addr,k
                                 	ldi	w,@1
                                 	sts	@0,w
                                 	.endmacro
                                 
                                 .macro	INC4			; increment
                                 	ldi	w,0xff
                                 	sub	@3,w
                                 	sbc	@2,w
                                 	sbc	@1,w
                                 	sbc	@0,w
                                 	.endmacro
                                 .macro	INC3
                                 	ldi	w,0xff
                                 	sub	@2,w
                                 	sbc	@1,w
                                 	sbc	@0,w
                                 	.endmacro
                                 .macro	INC2
                                 	ldi	w,0xff
                                 	sub	@1,w
                                 	sbc	@0,w
                                 	.endmacro
                                 
                                 .macro	DEC4			; decrement
                                 	ldi	w,0xff
                                 	add	@3,w
                                 	adc	@2,w
                                 	adc	@1,w
                                 	adc	@0,w
                                 	.endmacro
                                 .macro	DEC3
                                 	ldi	w,0xff
                                 	add	@2,w
                                 	adc	@1,w
                                 	adc	@0,w
                                 	.endmacro
                                 .macro	DEC2
                                 	ldi	w,0xff
                                 	add	@1,w
                                 	adc	@0,w
                                 	.endmacro
                                 
                                 .macro	CLR9			; clear (also clears the carry)
                                 	sub	@0,@0
                                 	clr	@1
                                 	clr	@2
                                 	clr	@3
                                 	clr	@4
                                 	clr	@5
                                 	clr	@6
                                 	clr	@7
                                 	clr	@8
                                 	.endmacro
                                 .macro	CLR8
                                 	sub	@0,@0
                                 	clr	@1
                                 	clr	@2
                                 	clr	@3
                                 	clr	@4
                                 	clr	@5
                                 	clr	@6
                                 	clr	@7
                                 	.endmacro
                                 .macro	CLR7
                                 	sub	@0,@0
                                 	clr	@1
                                 	clr	@2
                                 	clr	@3
                                 	clr	@4
                                 	clr	@5
                                 	clr	@6
                                 	.endmacro
                                 .macro	CLR6
                                 	sub	@0,@0
                                 	clr	@1
                                 	clr	@2
                                 	clr	@3
                                 	clr	@4
                                 	clr	@5
                                 	.endmacro
                                 .macro	CLR5
                                 	sub	@0,@0
                                 	clr	@1
                                 	clr	@2
                                 	clr	@3
                                 	clr	@4
                                 	.endmacro
                                 .macro	CLR4
                                 	sub	@0,@0
                                 	clr	@1
                                 	clr	@2
                                 	clr	@3
                                 	.endmacro
                                 .macro	CLR3
                                 	sub	@0,@0
                                 	clr	@1
                                 	clr	@2
                                 	.endmacro
                                 .macro	CLR2
                                 	sub	@0,@0
                                 	clr	@1
                                 	.endmacro
                                 
                                 .macro	COM4			; one's complement
                                 	com	@0
                                 	com	@1
                                 	com	@2
                                 	com	@3
                                 	.endmacro
                                 .macro	COM3
                                 	com	@0
                                 	com	@1
                                 	com	@2
                                 	.endmacro
                                 .macro	COM2
                                 	com	@0
                                 	com	@1
                                 	.endmacro
                                 
                                 .macro	NEG4			; negation (two's complement)
                                 	com	@0
                                 	com	@1
                                 	com	@2
                                 	com	@3
                                 	ldi	w,0xff
                                 	sub	@3,w
                                 	sbc	@2,w
                                 	sbc	@1,w
                                 	sbc	@0,w
                                 	.endmacro
                                 .macro	NEG3
                                 	com	@0
                                 	com	@1
                                 	com	@2
                                 	ldi	w,0xff
                                 	sub	@2,w
                                 	sbc	@1,w
                                 	sbc	@0,w
                                 	.endmacro
                                 .macro	NEG2
                                 	com	@0
                                 	com	@1
                                 	ldi	w,0xff
                                 	sub	@1,w
                                 	sbc	@0,w
                                 	.endmacro
                                 	
                                 .macro	LDI4 	; r..r0, k	; load immediate
                                 	ldi	@3,  low(@4)
                                 	ldi	@2, high(@4)
                                 	ldi	@1,byte3(@4)
                                 	ldi	@0,byte4(@4)
                                 	.endmacro
                                 .macro	LDI3
                                 	ldi	@2,  low(@3)
                                 	ldi	@1, high(@3)
                                 	ldi	@0,byte3(@3)
                                 	.endmacro
                                 .macro	LDI2
                                 	ldi	@1,  low(@2)
                                 	ldi	@0, high(@2)
                                 	.endmacro
                                 
                                 .macro	LDS4			; load direct from SRAM
                                 	lds	@3,@4
                                 	lds	@2,@4+1
                                 	lds	@1,@4+2
                                 	lds	@0,@4+3
                                 	.endmacro
                                 .macro	LDS3
                                 	lds	@2,@3
                                 	lds	@1,@3+1
                                 	lds	@0,@3+2
                                 	.endmacro
                                 .macro	LDS2
                                 	lds	@1,@2
                                 	lds	@0,@2+1
                                 	.endmacro
                                 
                                 .macro	STS4			; store direct to SRAM
                                 	sts	@0+0,@4
                                 	sts	@0+1,@3
                                 	sts	@0+2,@2
                                 	sts	@0+3,@1
                                 	.endmacro
                                 .macro	STS3
                                 	sts	@0+0,@3
                                 	sts	@0+1,@2
                                 	sts	@0+2,@1
                                 	.endmacro
                                 .macro	STS2
                                 	sts	@0+0,@2
                                 	sts	@0+1,@1
                                 	.endmacro
                                 
                                 .macro	STDZ4	; d, r3,r2,r1,r0
                                 	std	z+@0+0,@4
                                 	std	z+@0+1,@3
                                 	std	z+@0+2,@2
                                 	std	z+@0+3,@1
                                 	.endmacro
                                 .macro	STDZ3	; d, r2,r1,r0
                                 	std	z+@0+0,@3
                                 	std	z+@0+1,@2
                                 	std	z+@0+2,@1
                                 	.endmacro
                                 .macro	STDZ2	; d, r1,r0
                                 	std	z+@0+0,@2
                                 	std	z+@0+1,@1
                                 	.endmacro
                                 	
                                 .macro	LPM4			; load program memory
                                 	lpm
                                 	mov	@3,r0
                                 	adiw	zl,1
                                 	lpm
                                 	mov	@2,r0
                                 	adiw	zl,1
                                 	lpm
                                 	mov	@1,r0
                                 	adiw	zl,1
                                 	lpm
                                 	mov	@0,r0
                                 	adiw	zl,1
                                 	.endmacro
                                 .macro	LPM3
                                 	lpm
                                 	mov	@2,r0
                                 	adiw	zl,1
                                 	lpm
                                 	mov	@1,r0
                                 	adiw	zl,1
                                 	lpm
                                 	mov	@0,r0
                                 	adiw	zl,1
                                 	.endmacro
                                 .macro	LPM2
                                 	lpm
                                 	mov	@1,r0
                                 	adiw	zl,1
                                 	lpm
                                 	mov	@0,r0
                                 	adiw	zl,1
                                 	.endmacro
                                 .macro	LPM1
                                 	lpm
                                 	mov	@0,r0
                                 	adiw	zl,1
                                 	.endmacro
                                 
                                 .macro	MOV4			; move between registers
                                 	mov	@3,@7
                                 	mov	@2,@6
                                 	mov	@1,@5
                                 	mov	@0,@4
                                 	.endmacro
                                 .macro	MOV3
                                 	mov	@2,@5
                                 	mov	@1,@4
                                 	mov	@0,@3
                                 	.endmacro
                                 .macro	MOV2
                                 	mov	@1,@3
                                 	mov	@0,@2
                                 	.endmacro
                                 
                                 .macro	ADD4			; add
                                 	add	@3,@7
                                 	adc	@2,@6
                                 	adc	@1,@5
                                 	adc	@0,@4
                                 	.endmacro
                                 .macro	ADD3
                                 	add	@2,@5
                                 	adc	@1,@4
                                 	adc	@0,@3
                                 	.endmacro
                                 .macro	ADD2
                                 	add	@1,@3
                                 	adc	@0,@2
                                 	.endmacro
                                 
                                 .macro	SUB4			; subtract
                                 	sub	@3,@7
                                 	sbc	@2,@6
                                 	sbc	@1,@5
                                 	sbc	@0,@4
                                 	.endmacro
                                 .macro	SUB3
                                 	sub	@2,@5
                                 	sbc	@1,@4
                                 	sbc	@0,@3
                                 	.endmacro
                                 .macro	SUB2
                                 	sub	@1,@3
                                 	sbc	@0,@2
                                 	.endmacro
                                 	
                                 .macro	CP4			; compare
                                 	cp	@3,@7
                                 	cpc	@2,@6
                                 	cpc	@1,@5
                                 	cpc	@0,@4
                                 	.endmacro
                                 .macro	CP3
                                 	cp	@2,@5
                                 	cpc	@1,@4
                                 	cpc	@0,@3
                                 	.endmacro
                                 .macro	CP2
                                 	cp	@1,@3
                                 	cpc	@0,@2
                                 	.endmacro
                                 
                                 .macro	TST4			; test
                                 	clr	w
                                 	cp	@3,w
                                 	cpc	@2,w
                                 	cpc	@1,w
                                 	cpc	@0,w
                                 	.endmacro
                                 .macro	TST3
                                 	clr	w
                                 	cp	@2,w
                                 	cpc	@1,w
                                 	cpc	@0,w
                                 	.endmacro
                                 .macro	TST2
                                 	clr	w
                                 	cp	@1,w
                                 	cpc	@0,w
                                 	.endmacro
                                 
                                 .macro	ADDI4			; add immediate
                                 	subi	@3,  low(-@4)
                                 	sbci	@2, high(-@4)
                                 	sbci	@1,byte3(-@4)
                                 	sbci	@0,byte4(-@4)
                                 	.endmacro
                                 .macro	ADDI3
                                 	subi	@2,  low(-@3)
                                 	sbci	@1, high(-@3)
                                 	sbci	@0,byte3(-@3)
                                 	.endmacro
                                 .macro	ADDI2
                                 	subi	@1,  low(-@2)
                                 	sbci	@0, high(-@2)
                                 	.endmacro
                                 	
                                 .macro	SUBI4			; subtract immediate
                                 	subi	@3,  low(@4)
                                 	sbci	@2, high(@4)
                                 	sbci	@1,byte3(@4)
                                 	sbci	@0,byte4(@4)
                                 	.endmacro
                                 .macro	SUBI3
                                 	subi	@2,  low(@3)
                                 	sbci	@1, high(@3)
                                 	sbci	@0,byte3(@3)
                                 	.endmacro
                                 .macro	SUBI2
                                 	subi	@1,  low(@2)
                                 	sbci	@0, high(@2)
                                 	.endmacro
                                 
                                 .macro	LSL5			; logical shift left
                                 	lsl	@4
                                 	rol	@3
                                 	rol	@2
                                 	rol	@1
                                 	rol	@0
                                 	.endmacro
                                 .macro	LSL4
                                 	lsl	@3
                                 	rol	@2
                                 	rol	@1
                                 	rol	@0
                                 	.endmacro
                                 .macro	LSL3
                                 	lsl	@2
                                 	rol	@1
                                 	rol	@0
                                 	.endmacro
                                 .macro	LSL2
                                 	lsl	@1
                                 	rol	@0
                                 	.endmacro
                                 	
                                 .macro	LSR4			; logical shift right
                                 	lsr	@0
                                 	ror	@1
                                 	ror	@2
                                 	ror	@3
                                 	.endmacro
                                 .macro	LSR3
                                 	lsr	@0
                                 	ror	@1
                                 	ror	@2
                                 	.endmacro
                                 .macro	LSR2
                                 	lsr	@0
                                 	ror	@1
                                 	.endmacro
                                 
                                 .macro	ASR4			; arithmetic shift right
                                 	asr	@0
                                 	ror	@1
                                 	ror	@2
                                 	ror	@3
                                 	.endmacro
                                 .macro	ASR3
                                 	asr	@0
                                 	ror	@1
                                 	ror	@2
                                 	.endmacro
                                 .macro	ASR2
                                 	asr	@0
                                 	ror	@1
                                 	.endmacro
                                 
                                 .macro	ROL8			; rotate left through carry
                                 	rol	@7
                                 	rol	@6
                                 	rol	@5
                                 	rol	@4
                                 	rol	@3
                                 	rol	@2
                                 	rol	@1
                                 	rol	@0
                                 	.endmacro
                                 .macro	ROL7
                                 	rol	@6
                                 	rol	@5
                                 	rol	@4
                                 	rol	@3
                                 	rol	@2
                                 	rol	@1
                                 	rol	@0
                                 	.endmacro
                                 .macro	ROL6
                                 	rol	@5
                                 	rol	@4
                                 	rol	@3
                                 	rol	@2
                                 	rol	@1
                                 	rol	@0
                                 	.endmacro
                                 .macro	ROL5
                                 	rol	@4
                                 	rol	@3
                                 	rol	@2
                                 	rol	@1
                                 	rol	@0
                                 	.endmacro
                                 .macro	ROL4
                                 	rol	@3
                                 	rol	@2
                                 	rol	@1
                                 	rol	@0
                                 	.endmacro
                                 .macro	ROL3
                                 	rol	@2
                                 	rol	@1
                                 	rol	@0
                                 	.endmacro
                                 .macro	ROL2
                                 	rol	@1
                                 	rol	@0
                                 	.endmacro
                                 
                                 .macro	ROR8			; rotate right through carry
                                 	ror	@0
                                 	ror	@1
                                 	ror	@2
                                 	ror	@3
                                 	ror	@4
                                 	ror	@5
                                 	ror	@6
                                 	ror	@7
                                 	.endmacro
                                 .macro	ROR7
                                 	ror	@0
                                 	ror	@1
                                 	ror	@2
                                 	ror	@3
                                 	ror	@4
                                 	ror	@5
                                 	ror	@6
                                 	.endmacro
                                 .macro	ROR6
                                 	ror	@0
                                 	ror	@1
                                 	ror	@2
                                 	ror	@3
                                 	ror	@4
                                 	ror	@5
                                 	.endmacro
                                 .macro	ROR5
                                 	ror	@0
                                 	ror	@1
                                 	ror	@2
                                 	ror	@3
                                 	ror	@4
                                 	.endmacro	
                                 .macro	ROR4
                                 	ror	@0
                                 	ror	@1
                                 	ror	@2
                                 	ror	@3
                                 	.endmacro
                                 .macro	ROR3
                                 	ror	@0
                                 	ror	@1
                                 	ror	@2
                                 	.endmacro
                                 .macro	ROR2
                                 	ror	@0
                                 	ror	@1
                                 	.endmacro
                                 
                                 .macro	PUSH2
                                 	push	@0
                                 	push	@1
                                 	.endmacro	
                                 .macro	POP2
                                 	pop	@1
                                 	pop	@0
                                 	.endmacro
                                 
                                 .macro	PUSH3
                                 	push	@0
                                 	push	@1
                                 	push	@2
                                 	.endmacro	
                                 .macro	POP3
                                 	pop	@2
                                 	pop	@1
                                 	pop	@0
                                 	.endmacro
                                 	
                                 .macro	PUSH4
                                 	push	@0
                                 	push	@1
                                 	push	@2
                                 	push	@3
                                 	.endmacro	
                                 .macro	POP4
                                 	pop	@3
                                 	pop	@2
                                 	pop	@1
                                 	pop	@0
                                 	.endmacro	
                                 	
                                 .macro	PUSH5
                                 	pop	@0
                                 	pop	@1
                                 	pop	@2
                                 	pop	@3
                                 	pop	@4
                                 	.endmacro	
                                 .macro	POP5
                                 	pop	@4
                                 	pop	@3
                                 	pop	@2
                                 	pop	@1
                                 	pop	@0
                                 	.endmacro	
                                 
                                 ; --- SRAM operations ---
                                 .macro	INCS4	; sram		; increment SRAM 4-byte variable
                                 	lds	w,@0
                                 	inc	w
                                 	sts	@0,w
                                 	brne	end
                                 	lds	w,@0+1
                                 	inc	w
                                 	sts	@0+1,w
                                 	brne	end
                                 	lds	w,@0+2
                                 	inc	w
                                 	sts	@0+2,w
                                 	brne	end
                                 	lds	w,@0+3
                                 	inc	w
                                 	sts	@0+3,w
                                 end:	
                                 	.endmacro
                                 
                                 .macro	INCS3	; sram		; increment SRAM 3-byte variable
                                 	lds	w,@0
                                 	inc	w
                                 	sts	@0,w
                                 	brne	end
                                 	lds	w,@0+1
                                 	inc	w
                                 	sts	@0+1,w
                                 	brne	end
                                 	lds	w,@0+2
                                 	inc	w
                                 	sts	@0+2,w
                                 end:	
                                 	.endmacro
                                 
                                 .macro	INCS2	; sram		; increment SRAM 2-byte variable
                                 	lds	w,@0
                                 	inc	w
                                 	sts	@0,w
                                 	brne	end
                                 	lds	w,@0+1
                                 	inc	w
                                 	sts	@0+1,w
                                 end:	
                                 	.endmacro
                                 
                                 .macro	INCS	; sram		; increment SRAM 1-byte variable
                                 	lds	w,@0
                                 	inc	w
                                 	sts	@0,w
                                 	.endmacro
                                 
                                 .macro	DECS4	; sram		; decrement SRAM 4-byte variable
                                 	ldi	w,1
                                 	lds	u,@0
                                 	sub	u,w
                                 	sts	@0,u
                                 	clr	w
                                 	lds	u,@0+1
                                 	sbc	u,w
                                 	sts	@0+1,u
                                 	lds	u,@0+2
                                 	sbc	u,w
                                 	sts	@0+2,u
                                 	lds	u,@0+3
                                 	sbc	u,w
                                 	sts	@0+3,u
                                 	.endmacro
                                 .macro	DECS3	; sram		; decrement SRAM 3-byte variable
                                 	ldi	w,1
                                 	lds	u,@0
                                 	sub	u,w
                                 	sts	@0,u
                                 	clr	w
                                 	lds	u,@0+1
                                 	sbc	u,w
                                 	sts	@0+1,u
                                 	lds	u,@0+2
                                 	sbc	u,w
                                 	sts	@0+2,u
                                 	.endmacro
                                 .macro	DECS2	; sram		; decrement SRAM 2-byte variable
                                 	ldi	w,1
                                 	lds	u,@0
                                 	sub	u,w
                                 	sts	@0,u
                                 	clr	w
                                 	lds	u,@0+1
                                 	sbc	u,w
                                 	sts	@0+1,u
                                 	.endmacro
                                 .macro	DECS	; sram		; decrement
                                 	lds	w,@0
                                 	dec	w
                                 	sts	@0,w
                                 	.endmacro
                                 
                                 .macro	MOVS4	; addr0,addr1	; [addr0] <-- [addr1]
                                 	lds	w,@1
                                 	sts	@0,w
                                 	lds	w,@1+1
                                 	sts	@0+1,w
                                 	lds	w,@1+2
                                 	sts	@0+2,w
                                 	lds	w,@3+1
                                 	sts	@0+3,w	
                                 	.endmacro
                                 .macro	MOVS3	; addr0,addr1	; [addr0] <-- [addr1]
                                 	lds	w,@1
                                 	sts	@0,w
                                 	lds	w,@1+1
                                 	sts	@0+1,w
                                 	lds	w,@1+2
                                 	sts	@0+2,w
                                 	.endmacro
                                 .macro	MOVS2	; addr0,addr1	; [addr0] <-- [addr1]
                                 	lds	w,@1
                                 	sts	@0,w
                                 	lds	w,@1+1
                                 	sts	@0+1,w
                                 	.endmacro
                                 .macro	MOVS	; addr0,addr1	; [addr0] <-- [addr1]
                                 	lds	w,@1
                                 	sts	@0,w
                                 	.endmacro
                                 
                                 .macro	SEXT	; reg1,reg0	; sign extend
                                 	clr	@0
                                 	sbrc	@1,7
                                 	dec	@0
                                 	.endmacro
                                 
                                 ; =======================================
                                 ;	Jump/Call with constant arguments
                                 ; =======================================
                                 	
                                 ; --- calls with arguments a,b,XYZ ---
                                 .macro	CX	; subroutine,x
                                 	ldi	xl, low(@1)
                                 	ldi	xh,high(@1)
                                 	rcall	@0
                                 	.endmacro
                                 .macro	CXY	; subroutine,x,y
                                 	ldi	xl, low(@1)
                                 	ldi	xh,high(@1)
                                 	ldi	yl, low(@2)
                                 	ldi	yh,high(@2)	
                                 	rcall	@0
                                 	.endmacro		
                                 .macro	CXZ	; subroutine,x,z
                                 	ldi	xl, low(@1)
                                 	ldi	xh,high(@1)
                                 	ldi	zl, low(@2)
                                 	ldi	zh,high(@2)	
                                 	rcall	@0
                                 	.endmacro		
                                 .macro	CXYZ	; subroutine,x,y,z
                                 	ldi	xl, low(@1)
                                 	ldi	xh,high(@1)
                                 	ldi	yl, low(@2)
                                 	ldi	yh,high(@2)
                                 	ldi	zl, low(@3)
                                 	ldi	zh,high(@3)		
                                 	rcall	@0
                                 	.endmacro
                                 .macro	CW	; subroutine,w
                                 	ldi	w, @1
                                 	rcall	@0
                                 	.endmacro
                                 .macro	CA	; subroutine,a
                                 	ldi	a0, @1
                                 	rcall	@0
                                 	.endmacro
                                 .macro	CAB	; subroutine,a,b
                                 	ldi	a0, @1
                                 	ldi	b0, @2
                                 	rcall	@0
                                 	.endmacro
                                 
                                 ; --- jump with arguments w,a,b ---
                                 .macro	JW	; subroutine,w
                                 	ldi	w, @1
                                 	rjmp	@0
                                 	.endmacro
                                 .macro	JA	; subroutine,a
                                 	ldi	a0, @1
                                 	rjmp	@0
                                 	.endmacro
                                 .macro	JAB	; subroutine,a,b
                                 	ldi	a0, @1
                                 	ldi	b0, @2
                                 	rjmp	@0
                                 	.endmacro
                                 .list
                                 
                                 ; --------------- Ajoutes par mes soins (-Goz) -----------------------
                                 
                                 .macro 	LCDPUTS		; @0 string		; putstring of 16 characters on LCD
                                 		ldi		zl, low (2*(@0))	; load pointer to string
                                 		ldi		zh, high(2*(@0))
                                 		ldi		w, 16
                                 		mul		w, a1
                                 		add		zl,r0
                                 		rcall	LCD_putstring		; display string
                                 	.endmacro
                                 
                                 .macro	LDMASK		; @0 mask location,	@1 how to make the mask <=> ldi	@0,(1<<@1)
                                 		andi	@1,0x07				; create flag
                                 		ldi		@0,0x01
                                 		tst		@1
                                 		breq	PC+4
                                 		lsl		@0
                                 		dec		@1
                                 		rjmp	PC-4
                                 		com		@0
                                 	.endmacro
                                 
                                 .macro	JEU_INIT	; loads the next note to output in @0 when playing a song
                                 		lpm
                                 		ldi		_w,0xff
                                 		tst		r0
                                 		breq	PC+10				; jumps over macro
                                 		mov		w ,r0		
                                 		LDMASK	_w,w
                                 		mov		@0,_w
                                 		adiw	zl,1
                                 	.endmacro
                                 
                                 .macro	SHIFT_DIS	; shifts all the columns of the display, c0 will exit the matrix, and a new d3 will enter
                                 	mov	c0,c1
                                 	mov	c1,c2
                                 	mov	c2,c3
                                 	mov	c3,d0
                                 	mov	d0,d1
                                 	mov	d1,d2
                                 	mov	d2,d3
                                 	.endmacro
                                 
                                 ; =======================================
                                 ;			  CIRCULAR BUFFER
                                 ; =======================================
                                 
                                 .macro CB_INIT				; initialize circular buffer and display
                                 	ldi		w,0x00
                                 	sts		b_in, w
                                 	sts		b_out, w
                                 	sts		b_n, w
                                 	
                                 	clr		c0
                                 	clr		c1
                                 	clr		c2
                                 	clr		c3
                                 	clr		d0
                                 	clr		d1
                                 	clr		d2
                                 	clr		d3
                                 .endmacro
                                 
                                 
                                 
                                 .macro CB_PUSH				; push elem of the circular buffer to register @0
                                 	PUSH2	a0,a1
                                 	LDIZ	buffer
                                 	lds		a0, b_in
                                 	lds		a1, b_n
                                 	inc		a1
                                 	cpi		a1, rx_len		;TC
                                 	breq	cb_fin_push
                                 	ADDZ	a0
                                 	st		z, @0
                                 	INC_CYC	a0, 0, rx_len
                                 	sts		b_in, a0
                                 	sts		b_n, a1
                                 cb_fin_push:	
                                 	POP2	a0,a1
                                 .endmacro
                                 
                                 
                                 
                                 .macro CB_POP				; pop elem of the circular buffer to register @0
                                 	LDIZ	buffer
                                 	lds		a0, b_out
                                 	lds		a1, b_n
                                 	tst		a1				; cant give more
                                 	breq	cb_fin_pop
                                 	dec		a1
                                 	ADDZ	a0
                                 	ld		@0,z
                                 	INC_CYC	a0, 0, rx_len
                                 	sts		b_out, a0
                                 	sts		b_n, a1
                                 cb_fin_pop:	
                                 .include "definitions.asm"	; include register/constant definitions
                                 
                                 ; purpose library, definition of addresses and constants
                                 ; 20171114 A.S.
                                 
                                 ; === definitions  ===
                                 .list
                                 
                                 ; on aurait pu utiliser plus de macros afin d'amliorer la lisibilit du code (bcp de morceaux qu'on a crit existent en macro !)
                                 ; simplement on n'avait pas consience de leur existance au moment du dveloppement. 
                                 ; "La transmission des bits est ralise au moyen de macros plutt que par des boucles afin de garantir des timings prcis" -> avrLED
                                 
                                 ; pages 28, 34-37 pour nettoyer l'utilisation des variables
                                 ; dfinir les appels des registres par des noms constants (changement plus facile)
                                 
                                 
                                 ; ==================================== interrupt table =====================================
                                 
000000 940c 00fa                 	jmp	reset
                                 .org	0x0a
00000a 940c 0026                 	jmp	int_4	; PINE4..7
00000c 940c 0026                 	jmp	int_5
00000e 940c 0041                 	jmp	int_6
                                 .org	0x24 
000024 940c 0053                 	jmp uart_rxc
                                 
                                 
                                 ; ============================== interrupt service routines ================================
                                 
                                 int_4:	
000026 9130 0100                 int_5:	lds		a1,mode
000028 d111                      		rcall	encoder			; TO DO :  correct interrupts (encoder)
000029 3031
00002a f408
00002b e034
00002c 3035
00002d f008
00002e e031                      		CYCLIC	a1,1,4			; rapport, page 72 polycop pour MACROS, 127 pour ROUTINES, 
00002f 9330 0100                 		sts		mode,a1	; CYCLIC prend des nombres entre 1 et 255 => ncessiter d'incrmenter avant car on traite entre 0 et 3 sinon...
000031 953a                      		dec		a1
                                 
000032 d13c                      		rcall	LCD_clear
000033 e7e4
000034 e0f1
000035 e100
000036 9f03
000037 0de0
000038 d168                      		LCDPUTS	str0
000039 d162                      		rcall	LCD_lf
00003a ebe4
00003b e0f1
00003c e100
00003d 9f03
00003e 0de0
00003f d161                      		LCDPUTS str1
                                 
000040 c003                      		rjmp	int_6_endLoad
000041 9130 0100                 int_6:	lds		a1,mode	; sale incoming, chercher  changer pour la table de sauts ?
000043 953a                      		dec		a1
                                 int_6_endLoad:
000044 95a8                      		wdr				; reset watchdog timer
000045 9854                      		cbi		UCSR0B, RXEN0	; disable interrupt UART
000046 d578                      		rcall	led_clear_all
000047 fd31                      		sbrc	a1,1
000048 c005                      		rjmp	modes_23		; <=> PC+6 because jmp is 2 words long /!\
000049 ff30                      		sbrs	a1,0
00004a 940c 09f1                 		jmp		animation
00004c 940c 09f6                 		jmp		jeu 
                                 modes_23:
00004e ff30                      		sbrs	a1,0
00004f 940c 09fb                 		jmp		spectro
000051 940c 0a00                 		jmp		message
                                 
                                 uart_rxc: 
000053 b11c                      		in _w, UDR0
000054 932f
000055 933f
000056 e0e6
000057 e0f1
000058 9120 0103
00005a 9130 0105
00005c 9533
00005d 3430
00005e f079
00005f 0fe2
000060 f408
000061 5fff
000062 8310
000063 3420
000064 f420
000065 3020
000066 f010
000067 9523
000068 c001
000069 e020
00006a 9320 0103
00006c 9330 0105
00006e 913f
00006f 912f                      		CB_PUSH _w
000070 9518                      		reti
                                 
                                 
                                 
                                 ; =========================== constant chains & SRAM variables =============================					; move to definition.asm ?
                                 
                                 .dseg								; SRAM variables
000100                           	mode:	.byte	1
                                 .cseg
                                 
                                 tetris:								; music score
000071 9b9b
000072 ce00
000073 c500
000074 ac00
000075 00ac
000076 00c5
000077 00ce
000078 e7e7
000079 e700
00007a c500
00007b 9b00
00007c 009b
00007d 00ac
00007e 00c5                      .db		mi2,mi2,ns,si,ns,do2,ns,re2,re2,ns,do2,ns,si,ns,	la,la,ns,la,ns,do2,ns,mi2,mi2,ns,re2,ns,do2,ns		; odd number of bytes => padding
00007f cece
000080 c500
000081 00c5
000082 acac
000083 9b00
000084 009b
000085 c5c5
000086 e700
000087 00e7
000088 e7e7
000089 e7e7
00008a ac00                      .db		si,si,ns,do2,do2,ns,re2,re2,ns,mi2,mi2,ns,			do2,do2,ns,la,la,ns,la,la,la,la,ns,					re2
00008b 00ac
00008c 92ac
00008d 7070
00008e 8100
00008f 9200
000090 9b00
000091 009b
000092 009b
000093 00c5
000094 9b9b
000095 ac00
000096 c500
000097 ce00                      .db		re2,ns,re2,fa2,la2,la2,ns,so2,ns,fa2,ns,			mi2,mi2,ns,mi2,ns,do2,ns,mi2,mi2,ns,re2,ns,do2,ns,	si
000098 00ce
000099 c5c5
00009a ac00
00009b 00ac
00009c 9b9b
00009d c500
00009e 00c5
00009f e7e7
0000a0 e700
0000a1 e7e7
0000a2 00e7
0000a3 ffff
0000a4 ffff
0000a5 ffff
0000a6 ffff                      .db		si,ns,do2,do2,ns,re2,re2,ns,mi2,mi2,ns,				do2,do2,ns,la,la,ns,la,la,la,la,ns,end,				end,end,end,end,end,end,end
                                 
                                 victory_anim:						; led patterns
0000a7 ffff
0000a8 ffff
0000a9 ffff
0000aa ffff
0000ab 3f7f
0000ac 0f1f
0000ad 0307
0000ae 0001                      .db		0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,			0x7f,0x3f,0x1f,0x0f,0x07,0x03,0x01,					0x00
0000af 0000
0000b0 0000
0000b1 0000
0000b2 8000
0000b3 e0c0
0000b4 f8f0
0000b5 fefc                      .db		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x80,			0xc0,0xe0,0xf0,0xf8,0xfc,0xfe
0000b6 ffff
0000b7 ffff
0000b8 ffff
0000b9 ccff                      .db		0xff,0xff,0xff,0xff,0xff,0xff,0xff,eoc
                                 
                                 									; menu display
0000ba 4e41
0000bb 4d49
0000bc 5441
0000bd 4f49
0000be 204e
0000bf 2020
0000c0 6a20
0000c1 7565
0000c2 6e61
0000c3 6d69
0000c4 7461
0000c5 6f69
0000c6 206e
0000c7 2020
0000c8 4a20
0000c9 5545
0000ca 6e61
0000cb 6d69
0000cc 7461
0000cd 6f69
0000ce 206e
0000cf 2020
0000d0 6a20
0000d1 7565
0000d2 6e61
0000d3 6d69
0000d4 7461
0000d5 6f69
0000d6 206e
0000d7 2020
0000d8 6a20
0000d9 7565                      str0:	.db	"ANIMATION    jeu","animation    JEU","animation    jeu","animation    jeu"
0000da 7073
0000db 6365
0000dc 7274
0000dd 206f
0000de 6d20
0000df 7365
0000e0 6173
0000e1 6567
0000e2 7073
0000e3 6365
0000e4 7274
0000e5 206f
0000e6 6d20
0000e7 7365
0000e8 6173
0000e9 6567
0000ea 5053
0000eb 4345
0000ec 5254
0000ed 204f
0000ee 6d20
0000ef 7365
0000f0 6173
0000f1 6567
0000f2 7073
0000f3 6365
0000f4 7274
0000f5 206f
0000f6 4d20
0000f7 5345
0000f8 4153
0000f9 4547                      str1:	.db "spectro  message","spectro  message","SPECTRO  message","spectro  MESSAGE"
                                 
                                 ; ================================= initialization (reset) =================================
                                 
0000fa ef0f
0000fb bf0d
0000fc e100
0000fd bf0e                      reset:	LDSP	RAMEND				; load SP
0000fe d084                      		rcall	LCD_init			; initialize the LCD
0000ff e700
000100 bf09                      		OUTI	EIMSK, 0b01110000	; INT7..0
000101 e00a
000102 9300 003a                 		OUTEI	EICRB, 0b00001010	; INT7..4
                                 
000104 ef0f
000105 bb07                      		OUTI	DDRB, 0xff			; output LEDs
000106 ef0f
000107 bb08                      		OUTI	PORTB,0xff			; turn off LEDs
000108 e000
000109 bb01                      		OUTI	DDRD, 0x00			; input switchers
00010a d078                      		rcall	LCD_init			; initialize the LCD
00010b d027                      		rcall	encoder_init		; initialize rotary encoder
00010c e002
00010d b902                      		OUTI	DDRE,0b00000010		; make Tx (PE1) an output
00010e 9a19                      		sbi		PORTE,PE1			; set Tx to high
00010f 9a12                      		sbi		DDRE, SPEAKER		; initialize speaker				Sound -> sbi // Mute -> cbi
000110 9a57                      		sbi		UCSR0B, RXCIE0				; condenser l'?criture
000111 9852                      		cbi		UCSR0B, UCSZ02
000112 e006                      		ldi		w,(1<<UCSZ01)+(1<<UCSZ00)	; 8-bit, 1 stop bit, parity disabled CHECK
000113 9300 000a                 		sts		UCSR0B, w
                                 		
000115 e031                      		ldi		a1,0x01				; initialize mode value to 1
000116 9330 0100                 		sts		mode,a1
000118 953a                      		dec		a1					; initialize encoder value to 0
000119 e7e4
00011a e0f1
00011b e100
00011c 9f03
00011d 0de0
00011e d082                      		LCDPUTS	str0				; display default menu
00011f d07c                      		rcall	LCD_lf
000120 ebe4
000121 e0f1
000122 e100
000123 9f03
000124 0de0
000125 d07b                      		LCDPUTS str1
                                 
000126 95a8                      		wdr							; reset watchdog timer
000127 e108                      		ldi		w,0x18				; watchdog enable procedure (Safety level 1)
000128 bd01                      		out		WDTCR, w
000129 e00f                      		ldi		w,0x0f				
00012a bd01                      		out		WDTCR, w
                                 
00012b e00f                      		ldi		w, 0x0f				; load color for boot animation
00012c 2e20                      		mov		r2,w
00012d 2e40                      		mov		r4,w
00012e 2e50                      		mov		r5,w
00012f d557                      		rcall	anim_stand_by		; boot animation
                                 
000130 9478                      		sei							; set global interrupt
000131 940c 09f1                 		jmp		animation			; default mode
                                 
                                 
                                 .include "encoder.asm"		; include rotary encoder routines
                                 
                                 ; purpose library angular encoder operation
                                 
                                 ; === definitions ===
                                 .equ	ENCOD	= PORTE
                                 
                                 .dseg
000101                           enc_old:	.byte 1
                                 .cseg
                                 
                                 ; === routines ===
                                 
                                 encoder_init:
000133 b102                      	in		w,ENCOD-1		; make 3 lines input
000134 780f                      	andi	w,0b10001111
000135 b902                      	out		ENCOD-1,w
000136 b103                      	in		w,ENCOD			; enable 3 internal pull-ups
000137 6700                      	ori		w,0b01110000
000138 b903                      	out		ENCOD,w
000139 9508                      	ret
                                 
                                 encoder:
00013a 94e8                      	clt						; preclear T
00013b b111                      	in		_w,ENCOD-2		; read encoder port (_w=new)
00013c 7710                      	andi	_w,0b01110000	; mask encoder lines (A,B,I)
00013d 9020 0101                 	lds		_u, enc_old		; load prevous value (_u=old)
00013f 1512                      	cp		_w,_u			; compare new<>old ?
000140 f409                      	brne	PC+2			
000141 9508                      	ret						; if new=old then return
000142 9310 0101                 	sts		enc_old, _w		; store encoder value for next time
                                 
000144 fc26                      	sbrc	_u,ENCOD_I
000145 c002                      	rjmp	encoder_rot
000146 fd16                      	sbrc	_w,ENCOD_I
000147 9468                      	set
                                 	
                                 encoder_rot:
000148 fe24                      	sbrs	_u,ENCOD_A
000149 c007                      	rjmp	countercw
00014a fc25                      	sbrc	_u,ENCOD_B
00014b 9508                      	ret
00014c fd14                      	sbrc	_w,ENCOD_A
00014d 9508                      	ret
00014e fd15                      	sbrc	_w,ENCOD_B
00014f 9533                      	inc		a1
000150 9508                      	ret
                                 countercw:
000151 fe25                      	sbrs	_u,ENCOD_B
000152 9508                      	ret
000153 ff14                      	sbrs	_w,ENCOD_A
000154 9508                      	ret
000155 ff15                      	sbrs	_w,ENCOD_B
000156 953a                      	dec		a1
000157 9508                      	ret
                                 .include "lcd.asm"			; include the LCD routines
                                 
                                 ; purpose  LCD HD44780U library
                                 ; ATmega 128 and Atmel Studio 7.0 compliant
                                 
                                 ; === definitions ===
                                 .equ	LCD_IR	= 0x8000	; address LCD instruction reg
                                 .equ	LCD_DR	= 0xc000	; address LCD data register
                                 
                                 ; === subroutines ===
                                 LCD_wr_ir:
                                 ; in	w (byte to write to LCD IR)
000158 9030 8000                 	lds	u, LCD_IR		; read IR to check busy flag  (bit7)
00015a fc37
00015b cffc                      	JB1	u,7,LCD_wr_ir	; Jump if Bit=1 (still busy)
00015c d003                      	rcall	lcd_4us		; delay to increment DRAM addr counter
00015d 9300 8000                 	sts	LCD_IR, w		; store w in IR
00015f 9508                      	ret
                                 	
                                 lcd_4us:
000160 d000                      	rcall	lcd_2us		; recursive call		
                                 lcd_2us:
000161 0000                      	nop					; rcall(3) + nop(1) + ret(4) = 8 cycles (2us)
000162 9508                      	ret
                                 
                                 LCD:
                                 LCD_putc:
000163 302d
000164 f169                      	JK	a0,CR,LCD_cr	; Jump if a0=CR
000165 302a
000166 f1a9                      	JK	a0,LF,LCD_lf	; Jump if a0=LF
                                 
                                 LCD_wr_dr:
                                 ; in	a0 (byte to write to LCD DR)
000167 9100 8000                 	lds	w, LCD_IR		; read IR to check busy flag  (bit7)
000169 fd07
00016a cffc                      	JB1	w,7,LCD_wr_dr	; Jump if Bit=1 (still busy)
00016b dff4                      	rcall	lcd_4us		; delay to increment DRAM addr counter
00016c 9320 c000                 	sts	LCD_DR, a0		; store a0 in DR
00016e 9508                      	ret	
                                 	
00016f e001
000170 cfe7                      LCD_clear:			JW	LCD_wr_ir, 0b00000001	; clear display
000171 e002
000172 cfe5                      LCD_home:			JW	LCD_wr_ir, 0b00000010	; return home
000173 e100
000174 cfe3                      LCD_cursor_left:	JW	LCD_wr_ir, 0b00010000	; move cursor to left
000175 e104
000176 cfe1                      LCD_cursor_right:	JW	LCD_wr_ir, 0b00010100	; move cursor to right
000177 e108
000178 cfdf                      LCD_display_left:	JW	LCD_wr_ir, 0b00011000	; shifts display to left
000179 e10c
00017a cfdd                      LCD_display_right:	JW	LCD_wr_ir, 0b00011100	; shifts display to right
00017b e00d
00017c cfdb                      LCD_blink_on:		JW	LCD_wr_ir, 0b00001101	; Display=1,Cursor=0,Blink=1
00017d e00c
00017e cfd9                      LCD_blink_off:		JW	LCD_wr_ir, 0b00001100	; Display=1,Cursor=0,Blink=0
00017f e00e
000180 cfd7                      LCD_cursor_on:		JW	LCD_wr_ir, 0b00001110	; Display=1,Cursor=1,Blink=0
000181 e00c
000182 cfd5                      LCD_cursor_off:		JW	LCD_wr_ir, 0b00001100	; Display=1,Cursor=0,Blink=0
                                 		
                                 LCD_init:
000183 b705                      	in	w,MCUCR					; enable access to ext. SRAM
000184 6c00                      	sbr	w,(1<<SRE)+(1<<SRW10)
000185 bf05                      	out	MCUCR,w
000186 e001
000187 dfd0                      	CW	LCD_wr_ir, 0b00000001	; clear display
000188 e006
000189 dfce                      	CW	LCD_wr_ir, 0b00000110	; entry mode set (Inc=1, Shift=0)
00018a e00c
00018b dfcc                      	CW	LCD_wr_ir, 0b00001100	; Display=1,Cursor=0,Blink=0	
00018c e308
00018d dfca                      	CW	LCD_wr_ir, 0b00111000	; 8bits=1, 2lines=1, 5x8dots=0
00018e 9508                      	ret
                                 
                                 LCD_pos:
                                 ; in	a0 = position (0x00..0x0f first line, 0x40..0x4f second line)
00018f 2f02                      	mov	w,a0
000190 6800                      	ori	w,0b10000000
000191 cfc6                      	rjmp	LCD_wr_ir
                                 
                                 LCD_cr:
                                 ; moving the cursor to the beginning of the line (carriage return)
000192 9100 8000                 	lds	w, LCD_IR			; read IR to check busy flag  (bit7)
000194 fd07
000195 cffc                      	JB1	w,7,LCD_cr			; Jump if Bit=1 (still busy)
000196 7400                      	andi	w,0b01000000	; keep bit6 (begin of line 1/2)
000197 6800                      	ori	w,0b10000000		; write address command
000198 dfc7                      	rcall	lcd_4us			; delay to increment DRAM addr counter
000199 9300 8000                 	sts	LCD_IR,w			; store in IR
00019b 9508                      	ret
                                 
                                 LCD_lf:
                                 ; moving the cursor to the beginning of the line 2 (line feed)
00019c 932f                      	push	a0				; safeguard a0
00019d e420                      	ldi	a0,$40				; load position $40 (begin of line 2)
00019e dff0                      	rcall	LCD_pos			; set cursor position
00019f 912f                      	pop	a0					; restore a0
0001a0 9508                      	ret
                                 
                                 LCD_putstring:				; puts a full line on the display 
0001a1 e140                      		ldi		a2, 16
                                 next_char:
0001a2 95c8                      		lpm 				; load program memory into r0	 
0001a3 2d20                      		mov	 	a0, r0		; load argument
0001a4 dfbe                      		rcall	LCD_putc
0001a5 9631                      		adiw	zl, 1 		; increase pointer address
0001a6 5041                      		subi	a2, 1
0001a7 f7d1                      		brne	next_char
0001a8 9508                      		ret
                                 .include "printf.asm"		; include formated printing routines
                                 
                                 ; purpose library, formatted output generation
                                 ; author (c) R.Holzer (adapted MICRO210/EE208 A.Schmid)
                                 
                                 ; === description ===
                                 ; 
                                 ; The program "printf" interprets and prints formatted strings.
                                 ; The special formatting characters regognized are:
                                 ;
                                 ; FDEC	decimal number
                                 ; FHEX	hexadecimal number
                                 ; FBIN	binary number
                                 ; FFRAC	fixed fraction number
                                 ; FCHAR	single ASCII character
                                 ; FSTR	zero-terminated ASCII string
                                 	
                                 ; The special formatting characters are distinguished from normal 
                                 ; ASCII characters by having bit7 set to 1.
                                 
                                 ; Signification of bit fields:
                                 ;
                                 ; b 	bytes		1..4 b bytes		2
                                 ; s 	sign		0(unsigned), 1(signed)	1
                                 ; i		integer digits	
                                 ; e 	base		2,,36			5
                                 ; dp 	dec. point	0..32			5
                                 ; $if	i=integer digits,  0=all digits,  1..15 digits 
                                 ;		f=fraction digits, 0=no fraction, 1..15 digits
                                 ;
                                 ; Formatting characters must be followed by an SRAM address (0..ff)
                                 ; FBIN,	sram
                                 ; FHEX,	sram
                                 ; FDEC,	sram
                                 ; FCHAR,sram
                                 ; FSTR,	sram
                                 ;
                                 ; The address 'sram' is a 1-byte constant. It addresses
                                 ; 	 0..1f	registers r0..r31, 
                                 ; 	20..3f	i/o ports, (need to be addressed with an offset of $20)
                                 ;	60..ff	SRAM registers (warning: extended i/o in AVR128)
                                 
                                 ; The FFRAC formatting character must be followed by 
                                 ;	ONE sram address and 
                                 ;	TWO more formatting characters
                                 ; FFRAC,sram,dp,$if
                                 
                                 ; dp	decimal point position, 0=right, 32=left
                                 ; $if	format i.f, i=integer digits, f=fraction digits
                                 
                                 ; The special formatting characters use the following coding
                                 ;
                                 ; FDEC	11bb'iiis	i=0 all digits, i=1-7 digits
                                 ; FBIN	101i'iiis	i=0 8 digits,	i=1-7 digits
                                 ; FHEX	1001'iiis	i=0 8 digits,	i=1-7 digits
                                 ; FFRAC	1000'1bbs
                                 ; FCHAR	1000'0100
                                 ; FSTR	1000'0101
                                 ; FREP	1000'0110
                                 ; FFUNC	1000'0111
                                 ;	1000'0010
                                 ;	1000'0011
                                 ; FESC	1000'0000
                                 
                                 ; examples
                                 ; formatting string			printing
                                 ; "a=",FDEC,a,0				1-byte variable a, unsigned decimal
                                 ; "a=",FDEC2,a,0			2-byte variable a (a1,a0), unsigend
                                 ; "a=",FDEC|FSIGN,a,0		1-byte variable 1, signed decimal
                                 ; "n=",FBIN,PIND+$20,0		i/o port, binary, notice offset of $20
                                 ; "f=",FFRAC4|FSIGN,a,16,$88,0	4-byte signed fixed-point fraction
                                 ;				dec.point at 16, 8 int.digits, 8 frac.digits	
                                 ; "f=",FFRAC2,a,16,$18,0		2-byte unsigned fixed-point fraction
                                 ;				dec.point at 16, 1 int.digits, 8 frac.digits	
                                 ; "a=",FDEC|FDIG5|FSIGN,a,0	1-byte variable, 5-digit, decimal, signed
                                 ; "a=",FDEC|FDIG5,a,0		1-byte variable, 5-digit, decimal, unsigned
                                 
                                 ; === registers modified ===
                                 ; e0,e1	used to transmit address of putc routine
                                 ; zh,zl	used as pointer to prog-memory
                                 
                                 ; === constants ==============================================
                                 
                                 .equ	FDEC	= 0b11000000	; 1-byte variable
                                 .equ	FDEC2	= 0b11010000	; 2-byte variable
                                 .equ	FDEC3	= 0b11100000	; 3-byte variable
                                 .equ	FDEC4	= 0b11110000	; 4-byte variable
                                 
                                 .equ	FBIN	= 0b10100000
                                 .equ	FHEX	= 0b10010100	; 1-byte variable
                                 .equ	FHEX2	= 0b10011000	; 2-byte variable
                                 .equ	FHEX3	= 0b10011100	; 3-byte variable
                                 .equ	FHEX4	= 0b10010000	; 4-byte variable
                                 
                                 .equ	FFRAC	= 0b10001000	; 1-byte variable
                                 .equ	FFRAC2	= 0b10001010	; 2-byte variable
                                 .equ	FFRAC3	= 0b10001100	; 3-byte variable
                                 .equ	FFRAC4	= 0b10001110	; 4-byte variable
                                 
                                 .equ	FCHAR	= 0b10000100
                                 .equ	FSTR	= 0b10000101
                                 
                                 .equ	FSIGN	= 0b00000001
                                 
                                 .equ	FDIG1	= 1<<1
                                 .equ	FDIG2	= 2<<1
                                 .equ	FDIG3	= 3<<1	
                                 .equ	FDIG4	= 4<<1
                                 .equ	FDIG5	= 5<<1
                                 .equ	FDIG6	= 6<<1
                                 .equ	FDIG7	= 7<<1
                                 
                                 ; ===macro ====================================================
                                 
                                 .macro	PRINTF			; putc function (UART, LCD...)
                                 	ldi	w, low(@0)		; address of "putc" in e1:d0
                                 	mov	e0,w
                                 	ldi	w,high(@0)
                                 	mov	e1,w
                                 	rcall	_printf
                                 	.endmacro
                                 
                                 ; mod	y,z
                                 
                                 
                                 ; === routines ================================================
                                 
                                 _printf:
0001a9 91ff
0001aa 91ef                      	POPZ			; z points to begin of "string"
0001ab 0fee
0001ac 1fff                      	MUL2Z			; multiply Z by two, (word ptr -> byte ptr)
0001ad 93af
0001ae 93bf                      	PUSHX
                                 		
                                 _printf_read:
0001af 95c8                      	lpm				; places prog_mem(Z) into r0 (=c)
0001b0 9631                      	adiw	zl,1	; increment pointer Z
0001b1 2000                      	tst	r0			; test for ZERO (=end of string)
0001b2 f021                      	breq	_printf_end	; char=0 indicates end of ascii string
0001b3 f04a                      	brmi	_printf_formatted ; bit7=1 indicates formatting character
0001b4 2d00                      	mov	w,r0
0001b5 d013                      	rcall	_putw	; display the character
0001b6 cff8                      	rjmp	_printf_read	; read next character in the string
                                 	
                                 _printf_end:
0001b7 9631                      	adiw	zl,1	; point to the next character
0001b8 95f6
0001b9 95e7                      	DIV2Z			; divide by 2 (byte ptr -> word ptr)
0001ba 91bf
0001bb 91af                      	POPX
0001bc 9409                      	ijmp			; return to instruction after "string"
                                 
                                 _printf_formatted:
                                 
                                 ; FDEC	11bb'iiis
                                 ; FBIN	101i'iiis
                                 ; FHEX	1001'iiis
                                 ; FFRAC	1000'1bbs
                                 ; FCHAR	1000'0100
                                 ; FSTR	1000'0101
                                 
0001bd fa00                      	bst	r0,0		; store sign in T
0001be 2d00                      	mov	w,r0		; store formatting character in w
                                 
0001bf 95c8                      	lpm	
0001c0 2da0                      	mov	xl,r0		; load x-pointer with SRAM address
0001c1 27bb                      	clr	xh			; clear high-byte
0001c2 9631                       	adiw	zl,1	; increment pointer Z
                                 
                                 ;	JB1	w,6,_putdec
                                 ;	JB1	w,5,_putbin
                                 ;	JB1	w,4,_puthex
                                 ;	JB1	w,3,_putfrac
0001c3 3804
0001c4 f079                      	JK	w,FCHAR,_putchar
0001c5 3805
0001c6 f081                      	JK	w,FSTR ,_putstr
0001c7 c015                      	rjmp	_putnum
                                 	
0001c8 cfe6                      	rjmp	_printf_read	
                                 
                                 ; === putc (put character) ===============================
                                 ; in	w	character to put
                                 ;	e1,e0	address of output routine (UART, LCD putc)
                                 _putw:
0001c9 932f
0001ca 93ff
0001cb 93ef                      	PUSH3	a0,zh,zl
0001cc 2de4
0001cd 2df5
0001ce 2f20                      	MOV3	a0,zh,zl, w,e1,e0
0001cf 9509                      	icall			; indirect call to "putc"
0001d0 91ef
0001d1 91ff
0001d2 912f                      	POP3	a0,zh,zl
0001d3 9508                      	ret
                                 
                                 ; === putchar (put character) ============================
                                 ; in	x	pointer to character to put
                                 _putchar:
0001d4 910c                      	ld	w,x
0001d5 dff3                      	rcall	_putw
0001d6 cfd8                      	rjmp	_printf_read
                                 	
                                 ; === putstr (put string) ================================
                                 ; in	x	pointer to ascii string
                                 ;	b3,b2	address of output routine (UART, LCD putc)
                                 _putstr:
0001d7 910d                      	ld	w,x+
0001d8 2300                      	tst	w
0001d9 f409                      	brne	PC+2
0001da cfd4                      	rjmp	_printf_read
0001db dfed                      	rcall	_putw
0001dc cffa                      	rjmp	_putstr
                                 
                                 ; === putnum (dec/bin/hex/frac) ===========================
                                 ; in	x	pointer to SRAM variable to print
                                 ; 	r0	formatting character
                                 	
                                 _putnum:
0001dd 935f
0001de 934f
0001df 933f
0001e0 932f                      	PUSH4	a3,a2,a1,a0	; safeguard a
0001e1 939f
0001e2 938f
0001e3 937f
0001e4 936f                      	PUSH4	b3,b2,b1,b0	; safeguard b	
0001e5 912d
0001e6 913d
0001e7 914d
0001e8 915d                      	LDX4	a3,a2,a1,a0	; load operand to print into a
                                 
                                 ; FDEC	11bb'iiis
                                 ; FBIN	101i'iiis
                                 ; FHEX	1001'iiis
                                 ; FRACT	1000'1bbs
                                 
0001e9 fd06
0001ea c006                      	JB1	w,6,_putdec
0001eb fd05
0001ec c00f                      	JB1	w,5,_putbin
0001ed fd04
0001ee c010                      	JB1	w,4,_puthex
0001ef fd03
0001f0 c019                      	JB1	w,3,_putfrac
                                 
                                 ; FDEC	11bb'iiis
                                 _putdec:
0001f1 e06a                      	ldi	b0,10		; b0 = base (10)
                                 
0001f2 2f70                      	mov	b1,w
0001f3 9576                      	lsr	b1
0001f4 7077                      	andi	b1,0b111	
0001f5 9572                      	swap	b1		; b1 = format 0iii'0000 (integer digits)
0001f6 e080                      	ldi	b2,0		; b2 = dec. point position = 0 (right)
                                 	
0001f7 2f90                      	mov	b3,w
0001f8 9592                      	swap	b3
0001f9 7093                      	andi	b3,0b11
0001fa 9593                      	inc	b3			; b3 = number of bytes (1..4)
0001fb c01a                      	rjmp	_getnum	; get number of digits (iii)
                                 
                                 ; FBIN	101i'iiis	addr
                                 _putbin:	
0001fc e062                      	ldi	b0,2		; b0 = base (2)
0001fd e094                      	ldi	b3,4		; b3 = number of bytes (4)	
0001fe c003                      	rjmp	_getdig	; get number of digits (iii)
                                 
                                 ; FHEX	1001'iiis	addr
                                 _puthex:	
0001ff e160                      	ldi	b0,16		; b0 = base (16)
000200 e094                      	ldi	b3,4		; b3 = number of bytes (4)
000201 c000                      	rjmp	_getdig
                                 
                                 _getdig:
000202 2f70                      	mov	b1,w
000203 9576                      	lsr	b1
000204 7077                      	andi	b1,0b111
000205 f409                      	brne	PC+2
000206 e078                      	ldi	b1,8		; if b1=0 then 8-digits
000207 9572                      	swap	b1		; b1 = format 0iii'0000 (integer digits)
000208 e080                      	ldi	b2, 0		; b2 = dec. point position = 0 (right)
000209 c00c                      	rjmp	_getnum
                                 
                                 ; FFRAC	1000'1bbs	addr	 00dd'dddd, 	iiii'ffff
                                 	
                                 _putfrac:
00020a e06a                      	ldi	b0,10		; base=10	
00020b 95c8                      	lpm
00020c 2d80                      	mov	b2,r0		; load dec.point position
00020d 9631                      	adiw	zl,1	; increment char pointer
00020e 95c8                      	lpm
00020f 2d70                      	mov	b1,r0		; load ii.ff format
000210 9631                      	adiw	zl,1	; increment char pointer
                                 	
000211 2f90                      	mov	b3,w
000212 9595                      	asr	b3
000213 7093                      	andi	b3,0b11
000214 9593                      	inc	b3			; b3 = number of bytes (1..4)
                                 
000215 c000                      	rjmp	_getnum
                                 
                                 _getnum:
                                 ; in 	a	4-byte variable
                                 ; 	b3	number of bytes (1..4)
                                 ;	T	sign, 0=unsigned, 1=signed
                                 
000216 3094
000217 f081                      	JK	b3,4,_printf_4b
000218 3093
000219 f051                      	JK	b3,3,_printf_3b
00021a 3092
00021b f021                      	JK	b3,2,_printf_2b	
                                 	
                                 _printf_1b:			; sign extension
00021c 2733                      	clr	a1
00021d f416                      	brtc	PC+3	; T=1 sign extension
00021e fd27                      	sbrc	a0,7
00021f ef3f                      	ldi	a1,0xff
                                 _printf_2b:
000220 2744                      	clr	a2
000221 f416                      	brtc	PC+3	; T=1 sign extension	
000222 fd37                      	sbrc	a1,7
000223 ef4f                      	ldi	a2,0xff
                                 _printf_3b:	
000224 2755                      	clr	a3
000225 f416                      	brtc	PC+3	; T=1 sign extension
000226 fd47                      	sbrc	a2,7
000227 ef5f                      	ldi	a3,0xff
                                 _printf_4b:
                                 
000228 d009                      	rcall	_ftoa		; float to ascii
000229 916f
00022a 917f
00022b 918f
00022c 919f                      	POP4	b3,b2,b1,b0	; restore b
00022d 912f
00022e 913f
00022f 914f
000230 915f                      	POP4	a3,a2,a1,a0	; restore a
                                 	
000231 cf7d                      	rjmp	_printf_read
                                 
                                 ; ===============================================
                                 ; func	ftoa
                                 ; converts a fixed-point fractional number to an ascii string
                                 ; author (c) Raphael Holzer
                                 ;
                                 ; in	a3-a0	variable to print
                                 ;	b0	base, 2 to 36, but usually decimal (10)
                                 ;	b1	number of digits to print ii.ff
                                 ; 	b2	position of the decimal point (0=right, 32=left)
                                 ;	T	sign (T=0 unsiged, T=1 signed)
                                 
                                 _ftoa:
000232 92cf                      	push	d0
000233 92bf
000234 92af
000235 929f
000236 928f                      	PUSH4	c3,c2,c1,c0	; c = fraction part, a = integer part
000237 18bb
000238 24aa
000239 2499
00023a 2488                      	CLR4	c3,c2,c1,c0	; clear fraction part
                                 
00023b f486                      	brtc	_ftoa_plus	; if T=0 then unsigned
00023c 94e8                      	clt
00023d 2355                      	tst	a3				; if MSb(a)=1 then a=-a
00023e f46a                      	brpl	_ftoa_plus
00023f 9468                      	set					; T=1 (minus)
000240 2377                      	tst	b1
000241 f009                      	breq	PC+2		; if b1=0 the print ALL digits
000242 5170                      	subi	b1,0x10		; decrease int digits
000243 9550
000244 9540
000245 9530
000246 9520
000247 ef0f
000248 1b20
000249 0b30
00024a 0b40
00024b 0b50                      	NEG4	a3,a2,a1,a0	; negate a
                                 _ftoa_plus:	
00024c 2388                      	tst	b2				; b0=0 (only integer part)
00024d f051                      	breq	_ftoa_int	
                                 _ftoa_shift:	
00024e 9555
00024f 9547
000250 9537
000251 9527                      	ASR4	a3,a2,a1,a0	; a = integer part	
000252 94b7
000253 94a7
000254 9497
000255 9487                      	ROR4	c3,c2,c1,c0	; c = fraction part
000256 958a
000257 f7b1                      	DJNZ	b2,_ftoa_shift
                                 _ftoa_int:
000258 937f                      	push	b1			; ii.ff (ii=int digits)
000259 9572                      	swap	b1
00025a 707f                      	andi	b1,0x0f
                                 	
00025b e20e                      	ldi	w,'.'			; push decimal point
00025c 930f                      	push	w
                                 _ftoa_int1:
00025d d045                      	rcall	_div41		; int=int/10
00025e 2d0c                      	mov	w,d0			; d=reminder
00025f d030                      	rcall	_hex2asc
000260 930f                      	push	w			; push rem(int/10)
000261 2700
000262 1720
000263 0730
000264 0740
000265 0750                      	TST4	a3,a2,a1,a0	; (int/10)=?
000266 f029                      	breq	_ftoa_space	; (int/10)=0 then finished
000267 2377                      	tst	b1
000268 f3a1                      	breq	_ftoa_int1	; if b1=0 then print ALL int-digits
000269 957a
00026a f791                      	DJNZ	b1,_ftoa_int1
00026b c007                      	rjmp	_ftoa_sign
                                 _ftoa_space:
00026c 2377                      	tst	b1				; if b1=0 then print ALL int-digits
00026d f029                      	breq	_ftoa_sign
00026e 957a                      	dec	b1
00026f f019                      	breq	_ftoa_sign
000270 e200                      	ldi	w,' '			; write spaces
000271 df57                      	rcall	_putw	
000272 cff9                      	rjmp	_ftoa_space
                                 _ftoa_sign:
000273 f416                      	brtc	PC+3		; if T=1 then write 'minus'
000274 e20d                      	ldi	w,'-'
000275 df53                      	rcall	_putw
                                 _ftoa_int3:
000276 910f                      	pop	w
000277 320e                      	cpi	w,'.'
000278 f011                      	breq	PC+3
000279 df4f                      	rcall	_putw
00027a cffb                      	rjmp	_ftoa_int3
                                 
00027b 917f                      	pop	b1				; ii.ff (ff=frac digits)
00027c 707f                      	andi	b1,0x0f
00027d 2377                      	tst	b1
00027e f059                      	breq	_ftoa_end
                                 _ftoa_point:	
00027f df49                      	rcall	_putw		; write decimal point
000280 2d28
000281 2d39
000282 2d4a
000283 2d5b                      	MOV4	a3,a2,a1,a0, c3,c2,c1,c0		
                                 _ftoa_frac:
000284 d011                      	rcall	_mul41		; d.frac=10*frac
000285 2d0c                      	mov	w,d0
000286 d009                      	rcall	_hex2asc
000287 df41                      	rcall	_putw
000288 957a
000289 f7d1                      	DJNZ	b1,_ftoa_frac
                                 _ftoa_end:
00028a 908f
00028b 909f
00028c 90af
00028d 90bf                      	POP4	c3,c2,c1,c0
00028e 90cf                      	pop	d0
00028f 9508                      	ret
                                 
                                 ; === hexadecimal to ascii ===
                                 ; in	w
                                 _hex2asc:
000290 300a                      	cpi	w,10
000291 f410                      	brsh	PC+3
000292 5d00                      	addi	w,'0'
000293 9508                      	ret
000294 5a09                      	addi	w,('a'-10)
000295 9508                      	ret
                                 
                                 ; === multiply 4byte*1byte ===
                                 ; funct mul41
                                 ; multiplies a3-a0 (4-byte) by b0 (1-byte)
                                 ; author (c) Raphael Holzer, EPFL
                                 ; 
                                 ; in	a3..a0	multiplicand (argument to multiply)
                                 ;	b0	multiplier
                                 ; out	a3..a0	result
                                 ; 	d0	result MSB (byte 4)
                                 ;
000296 24cc                      _mul41:	clr	d0			; clear byte4 of result
000297 e200                      	ldi	w,32			; load bit counter
000298 9488                      __m41:	clc				; clear carry
000299 fd20                      	sbrc	a0,0		; skip addition if LSB=0
00029a 0ec6                      	add	d0,b0			; add b to MSB of a
00029b 94c7
00029c 9557
00029d 9547
00029e 9537
00029f 9527                      	ROR5	d0,a3,a2,a1,a0	; shift-right c, LSB (of b) into carry
0002a0 950a
0002a1 f7b1                      	DJNZ	w,__m41		; Decrement and Jump if bit-count Not Zero
0002a2 9508                      	ret
                                 
                                 ; === divide 4byte/1byte ===
                                 ; func div41
                                 ; in	a0..a3 	divident (argument to divide)
                                 ;	b0 	divider
                                 ; out	a0..a3 	result 
                                 ;	d0	reminder
                                 ;
0002a3 24cc                      _div41:	clr	d0			; d will contain the remainder
0002a4 e200                      	ldi	w,32			; load bit counter
0002a5 1f22
0002a6 1f33
0002a7 1f44
0002a8 1f55
0002a9 1ccc                      __d41:	ROL5	d0,a3,a2,a1,a0	; shift carry into result c
0002aa 1ac6                      	sub	d0, b0			; subtract b from remainder
0002ab f408                      	brcc	PC+2	
0002ac 0ec6                      	add	d0, b0			; restore if remainder became negative
0002ad 950a
0002ae f7b1                      	DJNZ	w,__d41		; Decrement and Jump if bit-count Not Zero
0002af 1f22
0002b0 1f33
0002b1 1f44
0002b2 1f55                      	ROL4	a3,a2,a1,a0	; last shift (carry into result c)
0002b3 9550
0002b4 9540
0002b5 9530
0002b6 9520                      	COM4	a3,a2,a1,a0	; complement result
0002b7 9508                      	ret
                                 .include "sound.asm"		; include sound routine
                                 
                                 ; purpose library, sound generation
                                 
                                 sound:
                                 ; in	a2	period of oscillation (in 10us)
                                 ; 		b0	duration of sound (in 2.5ms)
                                 
0002b8 2f76                      	mov		b1,b0			; duration high byte = b
0002b9 2766                      	clr		b0				; duration  low byte = 0
0002ba 2755                      	clr		a3				; period high byte = a
0002bb 2344                      	tst		a2
0002bc f071                      	breq	sound_off		; if a2=0 then no sound	
                                 sound1:
0002bd 2f84                      	mov		b2,a2		
0002be d025                      	rcall	button_analysis	; rcall	wait9us
0002bf 0000                      	nop						; 0.25us
0002c0 958a                      	dec		b2				; 0.25us
0002c1 f7e1                      	brne	PC-3			; 0.50us	total = 10us
0002c2 9b1a
0002c3 c002
0002c4 981a
0002c5 c001
0002c6 9a1a                      	INVP	PORTE,SPEAKER	; invert piezo output
0002c7 1b64                      	sub		b0,a2			; decrement duration low  byte
0002c8 0b75                      	sbc		b1,a3			; decrement duration high byte
0002c9 f798                      	brcc	sound1			; continue if duration>0
0002ca 9508                      	ret
                                 
                                 sound_off:
0002cb e041                      	ldi		a2,1
0002cc e00a
0002cd 2e30
0002ce e001
0002cf 930f
0002d0 923f
0002d1 e300
0002d2 2e30
0002d3 e006
0002d4 943a
0002d5 f7f1
0002d6 943a
0002d7 950a
0002d8 f7d9
0002d9 903f
0002da 910f
0002db 943a
0002dc f791
0002dd 950a
0002de f781                      	WAIT_MS	10
0002df 1b64                      	sub		b0,a2			; decrement duration low  byte
0002e0 0b75                      	sbc		b1,a3			; decrement duration high byte
0002e1 f7e8                      	brcc	PC-2			; continue if duration>0
0002e2 94e8                      	clt
0002e3 9508                      	ret
                                 
                                 ; === wait routines ===
                                 
                                 button_analysis:			; analyse the button input when a wait loop is needed
0002e4 b300                      		in		w,PIND		
0002e5 1508                      		cp		w,c0		
0002e6 f419                      		brne	PC+4
0002e7 94e8                      		clt					
0002e8 0000                      		nop
0002e9 c003                      		rjmp	PC+4
                                 
0002ea 3f0f                      		cpi		w,0xff		; no button pressed
0002eb f009                      		breq	PC+2
0002ec 2722                      		clr		a0			; will be avoided if buttons = MASK or 0
                                 							; total 7 cycles
0002ed e004
0002ee 2e30
0002ef e001
0002f0 943a
0002f1 f7f1
0002f2 943a
0002f3 950a
0002f4 f7d9                      		WAIT_US 4			; with these 2 instructions + rcall, ret : 18 cycles
0002f5 9508                      		ret					; by calling it twice, we wait 9us !
                                 
                                 ; === calculation of the musical scale ===
                                  
                                 ; period (10us)	= 100'000/freq(Hz)
                                 .equ	do	= 100000/517	; (517 Hz)
                                 .equ	dom	= do*944/1000	; do major
                                 .equ	re	= do*891/1000
                                 .equ	rem	= do*841/1000	; re major
                                 .equ	mi	= do*794/1000
                                 .equ	fa	= do*749/1000
                                 .equ	fam	= do*707/1000	; fa major
                                 .equ	so	= do*667/1000
                                 .equ	som	= do*630/1000	; so major
                                 .equ	la	= 0b11100111	; do*595/1000
                                 .equ	lam	= do*561/1000	; la major
                                 .equ	si	= 0b11001110	; do*530/1000
                                 
                                 .equ	do2	= 0b11000101	; do/2
                                 .equ	dom2	= dom/2
                                 .equ	re2	= 0b10101100	; re/2
                                 .equ	rem2	= rem/2
                                 .equ	mi2	= 0b10011011	; mi/2
                                 .equ	fa2	= 0b10010010	; fa/2
                                 .equ	fam2	= fam/2
                                 .equ	so2	= 0b10000001	; so/2
                                 .equ	som2	= som/2
                                 .equ	la2	= 0b01110000	; la/2
                                 .equ	lam2	= lam/2
                                 .equ	si2	= si/2
                                 
                                 .equ	do3	= do/4
                                 .equ	dom3	= dom/4
                                 .equ	re3	= re/4
                                 .equ	rem3	= rem/4
                                 .equ	mi3	= mi/4
                                 .equ	fa3	= fa/4
                                 .equ	fam3	= fam/4
                                 .equ	so3	= so/4
                                 .equ	som3	= som/4
                                 .equ	la3	= la/4
                                 .equ	lam3	= lam/4
                                 .equ	si3	= si/4	
                                 
                                 .equ	ns  = 0
                                 .equ	end = 0xff
                                 .include "avrLED.asm"		; include matrix routine
                                 
                                 ; avrLED.asm
                                 ;
                                 ; Created: 08.05.2018 16:56:25
                                 ; Author : Niccol Stefanini & Gauzelin Vidovic
                                 
                                 ;IN		c0,c1,c2,c3c,d0,d1,d2,d3	: 64 databits
                                 ;		r2,r4,r5					: 24 grb bits
                                 
                                 ;OUT	MAGIC
                                 
                                 ; ============================ MACROS ===============================
                                 
                                 .equ	min_rgb	= 0x01				; >= 0x01
                                 .equ	max_rgb	= 0x0c				; <= 0xfe
                                 
                                 
                                 
                                 .macro	SEND0	; 1: 250us, 0: 800 us	/!\ 8 MHz CLOCK
                                 		OUTI PORTB, 0xff
                                 		OUTI PORTB, 0x00
                                 ;		nop (x6); to get the correct cycle, but the wait is already ensured by the rest of the program
                                 .endmacro
                                 
                                 
                                 
                                 .macro	SEND1	; 1: 750us, 0: 500 us
                                 		OUTI PORTB, 0xff
                                 		nop
                                 		nop
                                 		nop
                                 		nop
                                 		OUTI PORTB, 0x00
                                 ;		nop (x2)
                                 .endmacro
                                 
                                 
                                 
                                 .macro SEND_RGB	; outputs LSB of @0
                                 		lsl		@0
                                 		brcs	rgb_else
                                 		SEND0
                                 		rjmp	rgb_end
                                 rgb_else:
                                 		SEND1
                                 rgb_end:
                                 .endmacro
                                 
                                 
                                 
                                 .macro LINE_OUT_RGB	; outputs full register @0 on the matrix, LSB out first
                                 		mov		r0 ,@0
                                 		ldi		_w,8
                                 line_rgb_loop:
                                 		lsr		r0
                                 		brcs	PC+3			; brcSET because masks are inverted (initially made for the switchers, which have pull-up connection)
                                 		rcall	led_rgb
                                 		rjmp	line_rgb_else
                                 		LED_CLEAR
                                 line_rgb_else:
                                 		dec		_w
                                 		brne	line_rgb_loop
                                 .endmacro
                                 
                                 
                                 
                                 .macro LINE_OUT_REV ; outputs full register @0 on the matrix, MSB out first
                                 		mov		r0 ,@0
                                 		ldi		_w,8
                                 		lsl		r0
                                 line_rgb_loop:
                                 		lsl		r0				; lsr
                                 		brcC	PC+3
                                 		rcall	led_rgb
                                 		rjmp	line_rgb_else
                                 		LED_CLEAR
                                 line_rgb_else:
                                 		dec		_w
                                 		brne	line_rgb_loop
                                 .endmacro
                                 
                                 
                                 
                                 
                                 .macro LED_CLEAR	; clear one led
                                 		PUSH3	r2,r4,r5
                                 		ldi		w, 0x00
                                 		mov		r2,w
                                 		mov		r4,w
                                 		mov		r5,w
                                 		rcall	led_rgb
                                 		POP3	r2,r4,r5
                                 .endmacro
                                 
                                 
                                 ; ============================ ROUTINES ===============================
                                 
                                 led_rgb:			; turns on one led with GBR parameters given by r2,r4,r5
0002f6 922f
0002f7 924f
0002f8 925f                      		PUSH3		r2,r4,r5
                                    
0002f9 0c22
0002fa f028
0002fb ef0f
0002fc bb08
0002fd e000
0002fe bb08
0002ff c008
000300 ef0f
000301 bb08
000302 0000
000303 0000
000304 0000
000305 0000
000306 e000
000307 bb08                      		SEND_RGB	r2; G7
000308 0c22
000309 f028
00030a ef0f
00030b bb08
00030c e000
00030d bb08
00030e c008
00030f ef0f
000310 bb08
000311 0000
000312 0000
000313 0000
000314 0000
000315 e000
000316 bb08                      		SEND_RGB	r2; G6
000317 0c22
000318 f028
000319 ef0f
00031a bb08
00031b e000
00031c bb08
00031d c008
00031e ef0f
00031f bb08
000320 0000
000321 0000
000322 0000
000323 0000
000324 e000
000325 bb08                      		SEND_RGB	r2; G5
000326 0c22
000327 f028
000328 ef0f
000329 bb08
00032a e000
00032b bb08
00032c c008
00032d ef0f
00032e bb08
00032f 0000
000330 0000
000331 0000
000332 0000
000333 e000
000334 bb08                      		SEND_RGB	r2; G4
000335 0c22
000336 f028
000337 ef0f
000338 bb08
000339 e000
00033a bb08
00033b c008
00033c ef0f
00033d bb08
00033e 0000
00033f 0000
000340 0000
000341 0000
000342 e000
000343 bb08                      		SEND_RGB	r2; G3
000344 0c22
000345 f028
000346 ef0f
000347 bb08
000348 e000
000349 bb08
00034a c008
00034b ef0f
00034c bb08
00034d 0000
00034e 0000
00034f 0000
000350 0000
000351 e000
000352 bb08                      		SEND_RGB	r2; G2
000353 0c22
000354 f028
000355 ef0f
000356 bb08
000357 e000
000358 bb08
000359 c008
00035a ef0f
00035b bb08
00035c 0000
00035d 0000
00035e 0000
00035f 0000
000360 e000
000361 bb08                      		SEND_RGB	r2; G1
000362 0c22
000363 f028
000364 ef0f
000365 bb08
000366 e000
000367 bb08
000368 c008
000369 ef0f
00036a bb08
00036b 0000
00036c 0000
00036d 0000
00036e 0000
00036f e000
000370 bb08                      		SEND_RGB	r2; G0
                                 		  
                                 	
000371 0c44
000372 f028
000373 ef0f
000374 bb08
000375 e000
000376 bb08
000377 c008
000378 ef0f
000379 bb08
00037a 0000
00037b 0000
00037c 0000
00037d 0000
00037e e000
00037f bb08                      		SEND_RGB	r4; R7
000380 0c44
000381 f028
000382 ef0f
000383 bb08
000384 e000
000385 bb08
000386 c008
000387 ef0f
000388 bb08
000389 0000
00038a 0000
00038b 0000
00038c 0000
00038d e000
00038e bb08                      		SEND_RGB	r4; R6
00038f 0c44
000390 f028
000391 ef0f
000392 bb08
000393 e000
000394 bb08
000395 c008
000396 ef0f
000397 bb08
000398 0000
000399 0000
00039a 0000
00039b 0000
00039c e000
00039d bb08                      		SEND_RGB	r4; R5
00039e 0c44
00039f f028
0003a0 ef0f
0003a1 bb08
0003a2 e000
0003a3 bb08
0003a4 c008
0003a5 ef0f
0003a6 bb08
0003a7 0000
0003a8 0000
0003a9 0000
0003aa 0000
0003ab e000
0003ac bb08                      		SEND_RGB	r4; R4
0003ad 0c44
0003ae f028
0003af ef0f
0003b0 bb08
0003b1 e000
0003b2 bb08
0003b3 c008
0003b4 ef0f
0003b5 bb08
0003b6 0000
0003b7 0000
0003b8 0000
0003b9 0000
0003ba e000
0003bb bb08                      		SEND_RGB	r4; R3
0003bc 0c44
0003bd f028
0003be ef0f
0003bf bb08
0003c0 e000
0003c1 bb08
0003c2 c008
0003c3 ef0f
0003c4 bb08
0003c5 0000
0003c6 0000
0003c7 0000
0003c8 0000
0003c9 e000
0003ca bb08                      		SEND_RGB	r4; R2
0003cb 0c44
0003cc f028
0003cd ef0f
0003ce bb08
0003cf e000
0003d0 bb08
0003d1 c008
0003d2 ef0f
0003d3 bb08
0003d4 0000
0003d5 0000
0003d6 0000
0003d7 0000
0003d8 e000
0003d9 bb08                      		SEND_RGB	r4; R1
0003da 0c44
0003db f028
0003dc ef0f
0003dd bb08
0003de e000
0003df bb08
0003e0 c008
0003e1 ef0f
0003e2 bb08
0003e3 0000
0003e4 0000
0003e5 0000
0003e6 0000
0003e7 e000
0003e8 bb08                      		SEND_RGB	r4; R0
                                 		
                                 
0003e9 0c55
0003ea f028
0003eb ef0f
0003ec bb08
0003ed e000
0003ee bb08
0003ef c008
0003f0 ef0f
0003f1 bb08
0003f2 0000
0003f3 0000
0003f4 0000
0003f5 0000
0003f6 e000
0003f7 bb08                      		SEND_RGB	r5; B7
0003f8 0c55
0003f9 f028
0003fa ef0f
0003fb bb08
0003fc e000
0003fd bb08
0003fe c008
0003ff ef0f
000400 bb08
000401 0000
000402 0000
000403 0000
000404 0000
000405 e000
000406 bb08                      		SEND_RGB	r5; B6
000407 0c55
000408 f028
000409 ef0f
00040a bb08
00040b e000
00040c bb08
00040d c008
00040e ef0f
00040f bb08
000410 0000
000411 0000
000412 0000
000413 0000
000414 e000
000415 bb08                      		SEND_RGB	r5; B5
000416 0c55
000417 f028
000418 ef0f
000419 bb08
00041a e000
00041b bb08
00041c c008
00041d ef0f
00041e bb08
00041f 0000
000420 0000
000421 0000
000422 0000
000423 e000
000424 bb08                      		SEND_RGB	r5; B4
000425 0c55
000426 f028
000427 ef0f
000428 bb08
000429 e000
00042a bb08
00042b c008
00042c ef0f
00042d bb08
00042e 0000
00042f 0000
000430 0000
000431 0000
000432 e000
000433 bb08                      		SEND_RGB	r5; B3
000434 0c55
000435 f028
000436 ef0f
000437 bb08
000438 e000
000439 bb08
00043a c008
00043b ef0f
00043c bb08
00043d 0000
00043e 0000
00043f 0000
000440 0000
000441 e000
000442 bb08                      		SEND_RGB	r5; B2
000443 0c55
000444 f028
000445 ef0f
000446 bb08
000447 e000
000448 bb08
000449 c008
00044a ef0f
00044b bb08
00044c 0000
00044d 0000
00044e 0000
00044f 0000
000450 e000
000451 bb08                      		SEND_RGB	r5; B1
000452 0c55
000453 f028
000454 ef0f
000455 bb08
000456 e000
000457 bb08
000458 c008
000459 ef0f
00045a bb08
00045b 0000
00045c 0000
00045d 0000
00045e 0000
00045f e000
000460 bb08                      		SEND_RGB	r5; B0
                                 	
000461 905f
000462 904f
000463 902f                      		POP3		r2,r4,r5
000464 9508                      		ret
                                 
                                 
                                 
                                 led_display_rgb:		; displays the registers c0...d3 on the matrix, with GBR bytes given by r2,r4,r5
000465 94f8                      		cli				; sends LSB out first
000466 2c08
000467 e018
000468 9406
000469 f010
00046a de8b
00046b c00b
00046c 922f
00046d 924f
00046e 925f
00046f e000
000470 2e20
000471 2e40
000472 2e50
000473 de82
000474 905f
000475 904f
000476 902f
000477 951a
000478 f779                      		LINE_OUT_RGB	c0
000479 2c09
00047a e018
00047b 9406
00047c f010
00047d de78
00047e c00b
00047f 922f
000480 924f
000481 925f
000482 e000
000483 2e20
000484 2e40
000485 2e50
000486 de6f
000487 905f
000488 904f
000489 902f
00048a 951a
00048b f779                      		LINE_OUT_RGB	c1
00048c 2c0a
00048d e018
00048e 9406
00048f f010
000490 de65
000491 c00b
000492 922f
000493 924f
000494 925f
000495 e000
000496 2e20
000497 2e40
000498 2e50
000499 de5c
00049a 905f
00049b 904f
00049c 902f
00049d 951a
00049e f779                      		LINE_OUT_RGB	c2
00049f 2c0b
0004a0 e018
0004a1 9406
0004a2 f010
0004a3 de52
0004a4 c00b
0004a5 922f
0004a6 924f
0004a7 925f
0004a8 e000
0004a9 2e20
0004aa 2e40
0004ab 2e50
0004ac de49
0004ad 905f
0004ae 904f
0004af 902f
0004b0 951a
0004b1 f779                      		LINE_OUT_RGB	c3
0004b2 2c0c
0004b3 e018
0004b4 9406
0004b5 f010
0004b6 de3f
0004b7 c00b
0004b8 922f
0004b9 924f
0004ba 925f
0004bb e000
0004bc 2e20
0004bd 2e40
0004be 2e50
0004bf de36
0004c0 905f
0004c1 904f
0004c2 902f
0004c3 951a
0004c4 f779                      		LINE_OUT_RGB	d0
0004c5 2c0d
0004c6 e018
0004c7 9406
0004c8 f010
0004c9 de2c
0004ca c00b
0004cb 922f
0004cc 924f
0004cd 925f
0004ce e000
0004cf 2e20
0004d0 2e40
0004d1 2e50
0004d2 de23
0004d3 905f
0004d4 904f
0004d5 902f
0004d6 951a
0004d7 f779                      		LINE_OUT_RGB	d1
0004d8 2c0e
0004d9 e018
0004da 9406
0004db f010
0004dc de19
0004dd c00b
0004de 922f
0004df 924f
0004e0 925f
0004e1 e000
0004e2 2e20
0004e3 2e40
0004e4 2e50
0004e5 de10
0004e6 905f
0004e7 904f
0004e8 902f
0004e9 951a
0004ea f779                      		LINE_OUT_RGB	d2
0004eb 2c0f
0004ec e018
0004ed 9406
0004ee f010
0004ef de06
0004f0 c00b
0004f1 922f
0004f2 924f
0004f3 925f
0004f4 e000
0004f5 2e20
0004f6 2e40
0004f7 2e50
0004f8 ddfd
0004f9 905f
0004fa 904f
0004fb 902f
0004fc 951a
0004fd f779                      		LINE_OUT_RGB	d3
0004fe 9478                      		sei
0004ff 9508                      		ret
                                 
                                 
                                 
                                 led_reverse_display:	; displays the registers c0...d3 on the matrix, with GBR bytes given by r2,r4,r5
000500 94f8                      		cli				; sends MSB out first
000501 2c08
000502 e018
000503 0c00
000504 0c00
000505 f410
000506 ddef
000507 c00b
000508 922f
000509 924f
00050a 925f
00050b e000
00050c 2e20
00050d 2e40
00050e 2e50
00050f dde6
000510 905f
000511 904f
000512 902f
000513 951a
000514 f779                      		LINE_OUT_REV	c0
000515 2c09
000516 e018
000517 0c00
000518 0c00
000519 f410
00051a dddb
00051b c00b
00051c 922f
00051d 924f
00051e 925f
00051f e000
000520 2e20
000521 2e40
000522 2e50
000523 ddd2
000524 905f
000525 904f
000526 902f
000527 951a
000528 f779                      		LINE_OUT_REV	c1
000529 2c0a
00052a e018
00052b 0c00
00052c 0c00
00052d f410
00052e ddc7
00052f c00b
000530 922f
000531 924f
000532 925f
000533 e000
000534 2e20
000535 2e40
000536 2e50
000537 ddbe
000538 905f
000539 904f
00053a 902f
00053b 951a
00053c f779                      		LINE_OUT_REV	c2
00053d 2c0b
00053e e018
00053f 0c00
000540 0c00
000541 f410
000542 ddb3
000543 c00b
000544 922f
000545 924f
000546 925f
000547 e000
000548 2e20
000549 2e40
00054a 2e50
00054b ddaa
00054c 905f
00054d 904f
00054e 902f
00054f 951a
000550 f779                      		LINE_OUT_REV	c3
000551 2c0c
000552 e018
000553 0c00
000554 0c00
000555 f410
000556 dd9f
000557 c00b
000558 922f
000559 924f
00055a 925f
00055b e000
00055c 2e20
00055d 2e40
00055e 2e50
00055f dd96
000560 905f
000561 904f
000562 902f
000563 951a
000564 f779                      		LINE_OUT_REV	d0
000565 2c0d
000566 e018
000567 0c00
000568 0c00
000569 f410
00056a dd8b
00056b c00b
00056c 922f
00056d 924f
00056e 925f
00056f e000
000570 2e20
000571 2e40
000572 2e50
000573 dd82
000574 905f
000575 904f
000576 902f
000577 951a
000578 f779                      		LINE_OUT_REV	d1
000579 2c0e
00057a e018
00057b 0c00
00057c 0c00
00057d f410
00057e dd77
00057f c00b
000580 922f
000581 924f
000582 925f
000583 e000
000584 2e20
000585 2e40
000586 2e50
000587 dd6e
000588 905f
000589 904f
00058a 902f
00058b 951a
00058c f779                      		LINE_OUT_REV	d2
00058d 2c0f
00058e e018
00058f 0c00
000590 0c00
000591 f410
000592 dd63
000593 c00b
000594 922f
000595 924f
000596 925f
000597 e000
000598 2e20
000599 2e40
00059a 2e50
00059b dd5a
00059c 905f
00059d 904f
00059e 902f
00059f 951a
0005a0 f779                      		LINE_OUT_REV	d3
0005a1 9478                      		sei
0005a2 9508                      		ret
                                 
                                 
                                 
                                 led_color_shift:		; shifts color within a given range (so it doesn't give out of control brightness)
0005a3 2d02                      		mov		w,r2
0005a4 5f0d                      		ADDI	w,3
0005a5 3001
0005a6 f408
0005a7 e00c
0005a8 300d
0005a9 f008
0005aa e001                      		CYCLIC	w,min_rgb,max_rgb
0005ab 2e20                      		mov		r2,w
0005ac 2d04                      		mov		w,r4
0005ad 5001                      		subi	w,1
0005ae 3001
0005af f408
0005b0 e00c
0005b1 300d
0005b2 f008
0005b3 e001                      		CYCLIC	w,min_rgb,max_rgb
0005b4 2e40                      		mov		r4,w
0005b5 2d05                      		mov		w,r5
0005b6 5002                      		subi	w,2
0005b7 3001
0005b8 f408
0005b9 e00c
0005ba 300d
0005bb f008
0005bc e001                      		CYCLIC	w,min_rgb,max_rgb
0005bd 2e50                      		mov		r5,w
0005be 9508                      		ret
                                 
                                 
                                 
                                 led_clear_all:			; clears completly the matrix display
0005bf 94f8                      		cli
0005c0 e410                      		ldi		_w,64
                                 led_clear_loop:
0005c1 922f
0005c2 924f
0005c3 925f
0005c4 e000
0005c5 2e20
0005c6 2e40
0005c7 2e50
0005c8 dd2d
0005c9 905f
0005ca 904f
0005cb 902f                      		LED_CLEAR
0005cc 951a                      		dec		_w
0005cd f799                      		brne	led_clear_loop
0005ce e804
0005cf 2e30
0005d0 e001
0005d1 943a
0005d2 f7f1
0005d3 943a
0005d4 950a
0005d5 f7d9                      		WAIT_US	100
0005d6 9478                      		sei
0005d7 9508                      		ret
                                 
                                 
                                 
                                 ;	Old stuff, but has some rgb color codes 
                                 /* led_clear:		; -Goz		1 = on, 0 = off, bits from 7...0
                                    ;Color	  ; Cl	Wh	Gr	Re	Bl	Ye	Pu	Or	...
                                 	SEND0 ; G ;	0	0	1	0	0
                                 	SEND0	  ; 0	0	1	0	0
                                 	SEND0	  ; 0	0	1	0	0
                                 	SEND0	  ; 0	0	1	0	0
                                 	SEND0	  ; 0	1	1	0	0
                                 	SEND0	  ; 0	1	1	0	0
                                 	SEND0	  ; 0	1	1	0	0
                                 	SEND0	  ; 0	1	1	0	0
                                 	
                                 	SEND0 ; R ; 0	0	0	1	0
                                 	SEND0	  ; 0	0	0	1	0
                                 	SEND0	  ; 0	0	0	1	0
                                 	SEND0	  ; 0	0	0	1	0
                                 	SEND0	  ; 0	1	0	1	0
                                 	SEND0	  ; 0	1	0	1	0
                                 	SEND0	  ; 0	1	0	1	0
                                 	SEND0	  ; 0	1	0	1	0
                                 
                                 	SEND0 ; B ; 0	0	0	0	1
                                 	SEND0	  ; 0	0	0	0	1
                                 	SEND0	  ; 0	0	0	0	1
                                 	SEND0	  ; 0	0	0	0	1
                                 	SEND0	  ; 0	1	0	0	1
                                 	SEND0	  ; 0	1	0	0	1
                                 	SEND0	  ; 0	1	0	0	1
                                 	SEND0	  ; 0	1	0	0	1
                                 .include "animation.asm"	; include animation mode
                                 
                                 ; animation.asm
                                 ;
                                 ; Created: 08.05.2018 16:56:25
                                 ; Author : Niccol Stefanini & Gauzelin Vidovic
                                 
                                  mode_anim:		; full animation routine,	beginning of Tetris track
0005d8 9478                      	    sei
0005d9 e004                      		ldi		w, 0x04
0005da 2e20                      		mov		r2,w
0005db e007                      		ldi		w, 0x07
0005dc 2e40                      		mov		r4,w
0005dd e00c                      		ldi		w, 0x0c
0005de 2e50                      		mov		r5,w
                                 
0005df eee2                      		ldi		zl, low (2*(tetris))
0005e0 e0f0                      		ldi		zh, high(2*(tetris))
0005e1 95c8
0005e2 ef1f
0005e3 2000
0005e4 f049
0005e5 2d00
0005e6 7007
0005e7 e011
0005e8 2300
0005e9 f019
0005ea 0f11
0005eb 950a
0005ec cffb
0005ed 9510
0005ee 2e81
0005ef 9631                      		JEU_INIT c0
0005f0 95c8
0005f1 ef1f
0005f2 2000
0005f3 f049
0005f4 2d00
0005f5 7007
0005f6 e011
0005f7 2300
0005f8 f019
0005f9 0f11
0005fa 950a
0005fb cffb
0005fc 9510
0005fd 2e91
0005fe 9631                      		JEU_INIT c1
0005ff 95c8
000600 ef1f
000601 2000
000602 f049
000603 2d00
000604 7007
000605 e011
000606 2300
000607 f019
000608 0f11
000609 950a
00060a cffb
00060b 9510
00060c 2ea1
00060d 9631                      		JEU_INIT c2
00060e 95c8
00060f ef1f
000610 2000
000611 f049
000612 2d00
000613 7007
000614 e011
000615 2300
000616 f019
000617 0f11
000618 950a
000619 cffb
00061a 9510
00061b 2eb1
00061c 9631                      		JEU_INIT c3
00061d 95c8
00061e ef1f
00061f 2000
000620 f049
000621 2d00
000622 7007
000623 e011
000624 2300
000625 f019
000626 0f11
000627 950a
000628 cffb
000629 9510
00062a 2ec1
00062b 9631                      		JEU_INIT d0
00062c 95c8
00062d ef1f
00062e 2000
00062f f049
000630 2d00
000631 7007
000632 e011
000633 2300
000634 f019
000635 0f11
000636 950a
000637 cffb
000638 9510
000639 2ed1
00063a 9631                      		JEU_INIT d1
00063b 95c8
00063c ef1f
00063d 2000
00063e f049
00063f 2d00
000640 7007
000641 e011
000642 2300
000643 f019
000644 0f11
000645 950a
000646 cffb
000647 9510
000648 2ee1
000649 9631                      		JEU_INIT d2
00064a 95c8
00064b ef1f
00064c 2000
00064d f049
00064e 2d00
00064f 7007
000650 e011
000651 2300
000652 f019
000653 0f11
000654 950a
000655 cffb
000656 9510
000657 2ef1
000658 9631                      		JEU_INIT d3
000659 de0b                      		rcall	led_display_rgb
                                 
00065a eee2                      		ldi		zl, low (2*(tetris))	; load pointer to music score
00065b e0f0                      		ldi		zh, high(2*(tetris))
                                 anim_play:
00065c 95a8                      		wdr					; reset watchdog timer
00065d df45                      		rcall	led_color_shift
00065e 01ef                      		movw	yl,zl		; PUSH2	zh,zl	would work too
00065f 9637                      		adiw	zl,7
000660 95c8                      		lpm		
000661 01fe                      		movw	zl,yl		; POP2	zh,zl	would work too
                                 
000662 2d00                      		mov		w ,r0		
000663 ef1f                      		ldi		_w,0xff		; outputs nothing if no tune	
000664 3f0f                      		cpi		w ,end
000665 f051                      		breq	anim_end_ini
000666 3000                      		cpi		w ,ns
000667 f041                      		breq	anim_end_ini
                                 
000668 7007
000669 e011
00066a 2300
00066b f019
00066c 0f11
00066d 950a
00066e cffb
00066f 9510                      		LDMASK	_w,w		; create mask
                                 anim_end_ini:
000670 2ef1                      		mov		d3,_w
000671 ddf3                      		rcall	led_display_rgb
                                 
000672 95c8                      		lpm					; load note to play
000673 2d40                      		mov		a2,r0		; move note to a2
000674 9631                      		adiw	zl,1		; increment pointer z
000675 9543                      		inc		a2			; so no_sound isn't considered as end of script
000676 2344                      		tst		a2			; test end of file (NUL)
000677 f061                      		breq	anim_end
000678 954a                      		dec		a2			; restore original value (remember inc)	
000679 9546                      		lsr		a2			; adjust the tune for 8 MHz instead of 4 MHz					
00067a e560                      		ldi		b0,bpm/2	; load play duration, twice as fast as game mode !
00067b dc3c                      		rcall	sound		; play the sound
00067c 2c89
00067d 2c9a
00067e 2cab
00067f 2cbc
000680 2ccd
000681 2cde
000682 2cef                      		SHIFT_DIS			; prepare display
                                 		
000683 cfd8                      		rjmp	anim_play
                                 anim_end:					; end of music track, infinite loop on second animation
000684 df1e                      		rcall	led_color_shift
000685 d001                      		rcall	anim_stand_by
000686 cffd                      		rjmp	anim_end
                                 
                                 ; ---------------------------------------------------------------------------
                                 
                                 anim_stand_by:				; second animation
000687 e4ee                      		ldi		zl, low (2*(victory_anim))
000688 e0f1                      		ldi		zh, high(2*(victory_anim))
000689 e058                      		ldi		a3,8
                                 anim_standBy_iLoop:
00068a 95c8                      		lpm					; initialize display
00068b 2cf0                      		mov		d3,r0
00068c 2c89
00068d 2c9a
00068e 2cab
00068f 2cbc
000690 2ccd
000691 2cde
000692 2cef                      		SHIFT_DIS
000693 9631                      		adiw	zl,1
000694 955a                      		dec		a3
000695 f7a1                      		brne	anim_standBy_iLoop
000696 ddce                      		rcall	led_display_rgb
000697 ec5c                      		ldi		a3,eoc		; end of chain
                                 anim_standBy_mLoop:
000698 e604
000699 2e30
00069a e001
00069b 930f
00069c 923f
00069d e300
00069e 2e30
00069f e006
0006a0 943a
0006a1 f7f1
0006a2 943a
0006a3 950a
0006a4 f7d9
0006a5 903f
0006a6 910f
0006a7 943a
0006a8 f791
0006a9 950a
0006aa f781                      		WAIT_MS	100			; shifts lines to make it move
0006ab 95a8                      		wdr					; reset watchdog timer
0006ac 95c8                      		lpm
0006ad 1605                      		cp		r0,a3		; test if end of chain
0006ae f059                      		breq	anim_standBy_end
0006af 2cf0                      		mov		d3,r0
0006b0 9631                      		adiw	zl,1
0006b1 ddb3                      		rcall	led_display_rgb
0006b2 2c89
0006b3 2c9a
0006b4 2cab
0006b5 2cbc
0006b6 2ccd
0006b7 2cde
0006b8 2cef                      		SHIFT_DIS
0006b9 cfde                      		rjmp	anim_standBy_mLoop
                                 anim_standBy_end:
                                 .include "jeu.asm"			; include game mode
0006ba 9508                      
                                 ; jeu.asm
                                 ;
                                 ; Created: 08.05.2018 16:56:25
                                 ; Author : Niccol Stefanini & Gauzelin Vidovic
                                 
                                 .dseg
000102                           	error_counter:	.byte	1
                                 .cseg
                                 
                                 mode_jeu:					; full game mode routine
0006bb 9478                      		sei
0006bc b300                      		in		w,PIND		; wait loop
0006bd 3f0f                      		cpi		w,0xff		; START if user presses any button
0006be f409                      		brne	PC+2
0006bf cffb                      		rjmp	mode_jeu
                                 
                                 	   ; == BEGINNING ==	; set up a lookup table for the masks with X pointer ?
                                 
0006c0 94f8                      	    cli					; YOU CAN'T INTERRUPT THE GAME (SO IT DOESN'T MESS UP THE DISPLAYS & RYTHM)
0006c1 95a8                      		wdr					; reset watchdog timer
0006c2 defc                      	    rcall	led_clear_all
                                 
0006c3 e100                      		ldi		w, 0x10		; initialize display color to green (no error yet)
0006c4 2e20                      		mov		r2,w
0006c5 e000                      		ldi		w, 0x00
0006c6 2e40                      		mov		r4,w
0006c7 2e50                      		mov		r5,w
0006c8 eee2                      		ldi		zl, low (2*(tetris))
0006c9 e0f0                      		ldi		zh, high(2*(tetris))
                                 
0006ca 95c8
0006cb ef1f
0006cc 2000
0006cd f049
0006ce 2d00
0006cf 7007
0006d0 e011
0006d1 2300
0006d2 f019
0006d3 0f11
0006d4 950a
0006d5 cffb
0006d6 9510
0006d7 2e81
0006d8 9631                      		JEU_INIT c0			; load initial score
0006d9 95c8
0006da ef1f
0006db 2000
0006dc f049
0006dd 2d00
0006de 7007
0006df e011
0006e0 2300
0006e1 f019
0006e2 0f11
0006e3 950a
0006e4 cffb
0006e5 9510
0006e6 2e91
0006e7 9631                      		JEU_INIT c1
0006e8 95c8
0006e9 ef1f
0006ea 2000
0006eb f049
0006ec 2d00
0006ed 7007
0006ee e011
0006ef 2300
0006f0 f019
0006f1 0f11
0006f2 950a
0006f3 cffb
0006f4 9510
0006f5 2ea1
0006f6 9631                      		JEU_INIT c2
0006f7 95c8
0006f8 ef1f
0006f9 2000
0006fa f049
0006fb 2d00
0006fc 7007
0006fd e011
0006fe 2300
0006ff f019
000700 0f11
000701 950a
000702 cffb
000703 9510
000704 2eb1
000705 9631                      		JEU_INIT c3
000706 95c8
000707 ef1f
000708 2000
000709 f049
00070a 2d00
00070b 7007
00070c e011
00070d 2300
00070e f019
00070f 0f11
000710 950a
000711 cffb
000712 9510
000713 2ec1
000714 9631                      		JEU_INIT d0
000715 95c8
000716 ef1f
000717 2000
000718 f049
000719 2d00
00071a 7007
00071b e011
00071c 2300
00071d f019
00071e 0f11
00071f 950a
000720 cffb
000721 9510
000722 2ed1
000723 9631                      		JEU_INIT d1
000724 95c8
000725 ef1f
000726 2000
000727 f049
000728 2d00
000729 7007
00072a e011
00072b 2300
00072c f019
00072d 0f11
00072e 950a
00072f cffb
000730 9510
000731 2ee1
000732 9631                      		JEU_INIT d2
000733 95c8
000734 ef1f
000735 2000
000736 f049
000737 2d00
000738 7007
000739 e011
00073a 2300
00073b f019
00073c 0f11
00073d 950a
00073e cffb
00073f 9510
000740 2ef1
000741 9631                      		JEU_INIT d3	
000742 dd22                      		rcall	led_display_rgb
                                 
000743 eee2                      		ldi		zl, low (2*(tetris))	; load pointer to music score 
000744 e0f0                      		ldi		zh, high(2*(tetris))	; (we could instead use PUSH2 POP2, but it's not faster whatsoever)
000745 9100 0102                 		lds		w,error_counter			; initialze error counter to 0
000747 2700                      		clr		w
000748 9300 0102                 		sts		error_counter,w
00074a ee08
00074b 2e30
00074c e004
00074d 930f
00074e 923f
00074f e300
000750 2e30
000751 e006
000752 943a
000753 f7f1
000754 943a
000755 950a
000756 f7d9
000757 903f
000758 910f
000759 943a
00075a f791
00075b 950a
00075c f781                      		WAIT_MS 1000		; wait for the user to release the button
                                 jeu_play:					; loop for a single note
00075d 95a8                      		wdr					; reset watchdog timer
00075e 9468                      		set					; initialize continue mark
00075f ef2f                      		ser		a0			; initialize mistake flag
                                 
000760 01ef                      		movw	yl,zl		; PUSH2	zh,zl	? 
000761 9637                      		adiw	zl,7		; looking for next note to appear on screen
000762 95c8                      		lpm		
000763 01fe                      		movw	zl,yl		; POP2	zh,zl	?
                                 
000764 2d00                      		mov		w ,r0		
000765 ef1f                      		ldi		_w,0xff		; default : outputs nothing if no tune	
000766 3f0f                      		cpi		w ,end		; is it the end of the music score ?
000767 f051                      		breq	jeu_end_ini
000768 3000                      		cpi		w ,ns		; is it "no sound" ?
000769 f041                      		breq	jeu_end_ini	; ---> if yes : no mask to load
                                 
00076a 7007
00076b e011
00076c 2300
00076d f019
00076e 0f11
00076f 950a
000770 cffb
000771 9510                      		LDMASK	_w,w		; create mask
                                 jeu_end_ini:				; branch if no new note to display (blank)
000772 2ef1                      		mov		d3,_w		; (can't use ldi with d3)
000773 dcf1                      		rcall	led_display_rgb		; display current music score
                                 
000774 95c8                      		lpm					; load note to play
000775 2d40                      		mov		a2,r0		; move note to a2
000776 9631                      		adiw	zl,1		; increment pointer z
000777 3f4f                      		cpi		a2,end		; test end of file
000778 f071                      		breq	jeu_victory_screen
000779 9546                      		lsr		a2			; adjust the tune for 8 MHz instead of 4 MHz
00077a ea60                      		ldi		b0,bpm		; load play duration (50*2.5ms = 125ms)
00077b db3c                      		rcall	sound		; play the sound
00077c 2c89
00077d 2c9a
00077e 2cab
00077f 2cbc
000780 2ccd
000781 2cde
000782 2cef                      		SHIFT_DIS			; prepare next display
                                 
000783 9520                      		com		a0			; result analysis
000784 f431                      		brne	jeu_error
000785 f02e                      		brts	jeu_error
                                 		
000786 cfd6                      		rjmp	jeu_play
                                 jeu_victory_screen:			; loops on animation while changing colors
000787 9478                      		sei
000788 de1a                      		rcall	led_color_shift
000789 defd                      		rcall	anim_stand_by
00078a cffc                      		rjmp	jeu_victory_screen
                                 
                                 jeu_error:					; subroutine if player made a mistake
00078b 2d02                      		mov		w,r2		; gradually shifts color from green to red
00078c 5004                      		subi	w,4
00078d 3000
00078e f408
00078f e100
000790 3101
000791 f008
000792 e000                      		CYCLIC	w,0x00,0x10
000793 2e20                      		mov		r2,w
000794 2d04                      		mov		w,r4
000795 5f0c                      		ADDI	w,4
000796 3000
000797 f408
000798 e100
000799 3101
00079a f008
00079b e000                      		CYCLIC	w,0x00,0x10
00079c 2e40                      		mov		r4,w
                                 		
00079d 9100 0102                 		lds		w,error_counter
00079f 9503                      		inc		w
0007a0 9300 0102                 		sts		error_counter,w
0007a2 ff02                      		sbrs	w,2			; lose when w = 0b00000100 => "4 lives"
0007a3 cfb9                      		rjmp	jeu_play	; continues w/ next note if more lives left
                                 jeu_over:					; else, display mistake and reset game
0007a4 dcc0                      		rcall	led_display_rgb	
0007a5 e604
0007a6 2e30
0007a7 e001
0007a8 930f
0007a9 923f
0007aa e300
0007ab 2e30
0007ac e006
0007ad 943a
0007ae f7f1
0007af 943a
0007b0 950a
0007b1 f7d9
0007b2 903f
0007b3 910f
0007b4 943a
0007b5 f791
0007b6 950a
0007b7 f781                      		WAIT_MS	100
0007b8 95a8                      		wdr					; reset watchdog timer
0007b9 b300                      		in		w,PIND		; wait loop
0007ba 3f0f                      		cpi		w,0xff		; RESET if user presses any button
0007bb f409                      		brne	PC+2
0007bc cffb                      		rjmp	PC-4
0007bd ee08
0007be 2e30
0007bf e004
0007c0 930f
0007c1 923f
0007c2 e300
0007c3 2e30
0007c4 e006
0007c5 943a
0007c6 f7f1
0007c7 943a
0007c8 950a
0007c9 f7d9
0007ca 903f
0007cb 910f
0007cc 943a
0007cd f791
0007ce 950a
0007cf f781                      		WAIT_MS	1000
0007d0 ddee                      		rcall	led_clear_all
0007d1 95a8                      		wdr					; reset watchdog timer
0007d2 cee8                      		rjmp	mode_jeu
                                 
                                 ; ------------------------------------------------------------------------------------------
                                 
                                 .include "spectro.asm"		; include spectrometer mode
                                 
0007d3 9478                      	sei
0007d4 e000                      	ldi		w, 0x00		; set colors
0007d5 2e20                      	mov		r2,w
0007d6 e003                      	ldi		w, 0x03
0007d7 2e40                      	mov		r4,w
0007d8 e009                      	ldi		w, 0x09
0007d9 2e50                      	mov		r5,w
                                 
0007da e303
0007db b909                      	OUTI	UBRR0L, 0x33				; baud 4800 for 8 Mhz clock
0007dc 9a54                      	sbi		UCSR0B, RXEN0
                                 
                                 	;rcall	led_clear_all
0007dd e000
0007de 9300 0103
0007e0 9300 0104
0007e2 9300 0105
0007e4 2488
0007e5 2499
0007e6 24aa
0007e7 24bb
0007e8 24cc
0007e9 24dd
0007ea 24ee
0007eb 24ff                      	CB_INIT
0007ec 94e8                      	clt
                                 	
                                 
                                 spe_t_serial_loop:
0007ed 95a8                      	wdr				; reset watchdog timer
0007ee 9190 0105                 	lds			b3, b_n ; check if letters in buffer
0007f0 2399                      	tst			b3
0007f1 f3d9                      	breq		spe_t_serial_loop
0007f2 e078                      	ldi			b1, 8
0007f3 e0e6
0007f4 e0f1
0007f5 9120 0104
0007f7 9130 0105
0007f9 2333
0007fa f081
0007fb 953a
0007fc 0fe2
0007fd f408
0007fe 5fff
0007ff 8150
000800 3420
000801 f420
000802 3020
000803 f010
000804 9523
000805 c001
000806 e020
000807 9320 0104
000809 9330 0105                 	CB_POP		a3	; the letter is on the table
00080b 3250                      	cpi			a3, SPACE
00080c f701                      	brne		spe_t_serial_loop
00080d e304
00080e 2e30
00080f e006
000810 943a
000811 f7f1
000812 943a
000813 950a
000814 f7d9                      	WAIT_US 	1000
                                 spe_getFft:
000815 95a8                      	wdr					; reset watchdog timer
000816 9190 0105                 	lds			b3, b_n ; check if letters in buffer
000818 2399                      	tst			b3
000819 f3d9                      	breq		spe_getFft
00081a e0e6
00081b e0f1
00081c 9120 0104
00081e 9130 0105
000820 2333
000821 f081
000822 953a
000823 0fe2
000824 f408
000825 5fff
000826 8150
000827 3420
000828 f420
000829 3020
00082a f010
00082b 9523
00082c c001
00082d e020
00082e 9320 0104
000830 9330 0105                 	CB_POP		a3
000832 5350                      	subi		a3, N0
000833 e4e6
000834 e0f8                      	LDIZ		fourier
000835 0fee
000836 1fff                      	MUL2Z	
000837 0fe5
000838 f408
000839 5fff                      	ADDZ		a3
00083a 2c89
00083b 2c9a
00083c 2cab
00083d 2cbc
00083e 2ccd
00083f 2cde
000840 2cef                      	SHIFT_DIS
000841 90f4                      	lpm 		d3, z
000842 957a                      	dec			b1
000843 f689                      	brne 		spe_getFft
000844 dc20                      	rcall		led_display_rgb
000845 cfa7                      	rjmp		spe_t_serial_loop
                                 
                                 fourier:
000846 feff
000847 f8fc
000848 e0f0
000849 80c0                      .include "message.asm"		; include message mode
00084a 0000                      
                                 ; message.asm
                                 ;
                                 ; Created: 08.05.2018 16:56:25
                                 ; Author : Niccol? Stefanini & Gauzelin Vidovic
                                 
                                 ; ============================ MACROS ===============================
                                 
                                 .macro 	MES_CHARCHECK		; @0 ascii code to data offset
                                 	LDIZ	tldr
                                 	cpi		@0, SPACE
                                 	brne	testep
                                 	ldi		@0, 0x00		; load space
                                 	rjmp	ccheck_fin
                                 testep:
                                 	cpi		@0, ASCII_EP
                                 	brne	testap
                                 	ldi		@0, 0x02		; load !
                                 	rjmp	ccheck_fin
                                 testap:
                                 	cpi		@0, ASCII_AP
                                 	brne	testnum
                                 	ldi		@0, 0x03		; load ''
                                 	rjmp	ccheck_fin
                                 testnum:
                                 	cpi		@0, N0
                                 	brlt	testletter
                                 	cpi		@0, N9
                                 	brge	testletter
                                 	subi	@0, N0 - OF_NUM
                                 	rjmp	ccheck_fin
                                 testletter:
                                 	cpi		@0, ASCII_A
                                 	brlt	testlmin
                                 	cpi		@0, ASCII_Z+1
                                 	brge	testlmin
                                 	subi	@0, ASCII_A - OF_LET
                                 	rjmp	ccheck_fin
                                 testlmin:
                                 	cpi		@0, ASCII_am
                                 	brlt	testqm
                                 	cpi		@0, ASCII_zm+1
                                 	brge	testqm
                                 	subi	@0, ASCII_am
                                 	LDIZ	tldr_min
                                 	rjmp	ccheck_fin
                                 testqm:
                                 	ldi		@0, 1
                                 ccheck_fin:
                                 .endmacro
                                 
                                 
                                 
                                 .macro	MES_OUTPUT_SPACE; subroutine to output a blank row on matrix (for spaces or end of transmission)
                                 	wdr					; reset watchdog timer
                                 	WAIT_MS mes_t_shift
                                 	SHIFT_DIS
                                 	_LDI	d3, clear	; whiteline
                                 	rcall	led_reverse_display
                                 	lds		b3, b_n
                                 	tst		b3			; check no new char in buffer
                                 .endmacro
                                 
                                 ; =========================== ROUTINES ==============================
                                 
                                 
                                 mode_message:			; full message mode routine (analyse UART transmission and display on matrix) 
00084b 9478                      	sei
00084c e00f                      	ldi		w, 0x0f		; set colors
00084d 2e20                      	mov		r2,w
00084e e000                      	ldi		w, 0x00
00084f 2e40                      	mov		r4,w
000850 e000                      	ldi		w, 0x00
000851 2e50                      	mov		r5,w
                                 
000852 e303
000853 b909                      	OUTI	UBRR0L, 0x33	; baud 4800 for 8 Mhz clock
000854 9a54                      	sbi		UCSR0B, RXEN0
                                 
                                 	;rcall	led_clear_all
000855 e000
000856 9300 0103
000858 9300 0104
00085a 9300 0105
00085c 2488
00085d 2499
00085e 24aa
00085f 24bb
000860 24cc
000861 24dd
000862 24ee
000863 24ff                      	CB_INIT
                                 
                                 mes_t_serial_loop:		; wait loop
000864 95a8                      	wdr					; reset watchdog timer
000865 9190 0105                 	lds		b3, b_n		; check if letters in buffer
000867 2399                      	tst		b3
000868 f3d9                      	breq	mes_t_serial_loop
000869 e708
00086a 2e30
00086b e001
00086c 930f
00086d 923f
00086e e300
00086f 2e30
000870 e006
000871 943a
000872 f7f1
000873 943a
000874 950a
000875 f7d9
000876 903f
000877 910f
000878 943a
000879 f791
00087a 950a
00087b f781                      	WAIT_MS mes_t_shift
                                 						; start of analyse process
00087c e0e6
00087d e0f1
00087e 9120 0104
000880 9130 0105
000882 2333
000883 f081
000884 953a
000885 0fe2
000886 f408
000887 5fff
000888 8150
000889 3420
00088a f420
00088b 3020
00088c f010
00088d 9523
00088e c001
00088f e020
000890 9320 0104
000892 9330 0105                 	CB_POP		a3		; the letter is on the table
000894 e2eb
000895 e0f9
000896 3250
000897 f411
000898 e050
000899 c01d
00089a 3251
00089b f411
00089c e052
00089d c019
00089e 3257
00089f f411
0008a0 e053
0008a1 c015
0008a2 3350
0008a3 f024
0008a4 335a
0008a5 f414
0008a6 525c
0008a7 c00f
0008a8 3451
0008a9 f024
0008aa 355b
0008ab f414
0008ac 5353
0008ad c009
0008ae 3651
0008af f034
0008b0 375b
0008b1 f424
0008b2 5651
0008b3 eae3
0008b4 e0f9
0008b5 c001
0008b6 e051                      	MES_CHARCHECK	a3	; a3 now is the offset of table
0008b7 0f55                      	lsl			a3		; a3.6 because there is 6 bytes for each char in the lookup table
0008b8 2f05                      	mov			w,a3
0008b9 0f55                      	lsl			a3
0008ba 0f50                      	add			a3,w
0008bb 0fee
0008bc 1fff                      	MUL2Z
0008bd 0fe5
0008be f408
0008bf 5fff                      	ADDZ		a3
0008c0 9145                      	lpm			a2, z+
                                 mes_sendout_loop:		; display a row of LEDs according to ASCII code
0008c1 95a8                      	wdr					; reset watchdog timer
0008c2 2c89
0008c3 2c9a
0008c4 2cab
0008c5 2cbc
0008c6 2ccd
0008c7 2cde
0008c8 2cef                      	SHIFT_DIS
0008c9 90f5                      	lpm		d3, z+
0008ca dc35                      	rcall	led_reverse_display
0008cb 954a                      	dec		a2
0008cc f0a1                      	breq	mes_fin_affichage ; other letter other gift
0008cd e708
0008ce 2e30
0008cf e001
0008d0 930f
0008d1 923f
0008d2 e300
0008d3 2e30
0008d4 e006
0008d5 943a
0008d6 f7f1
0008d7 943a
0008d8 950a
0008d9 f7d9
0008da 903f
0008db 910f
0008dc 943a
0008dd f791
0008de 950a
0008df f781                      	WAIT_MS mes_t_shift
0008e0 cfe0                      	rjmp	mes_sendout_loop
                                 
                                 mes_fin_affichage:		; output space between two characters
0008e1 95a8
0008e2 e708
0008e3 2e30
0008e4 e001
0008e5 930f
0008e6 923f
0008e7 e300
0008e8 2e30
0008e9 e006
0008ea 943a
0008eb f7f1
0008ec 943a
0008ed 950a
0008ee f7d9
0008ef 903f
0008f0 910f
0008f1 943a
0008f2 f791
0008f3 950a
0008f4 f781
0008f5 2c89
0008f6 2c9a
0008f7 2cab
0008f8 2cbc
0008f9 2ccd
0008fa 2cde
0008fb 2cef
0008fc e000
0008fd 2ef0
0008fe dc01
0008ff 9190 0105
000901 2399                      	MES_OUTPUT_SPACE
000902 f009                      	breq	PC+2
000903 cf60                      	rjmp	mes_t_serial_loop
                                 
000904 e088                      	ldi		b2,8
                                 mes_fade_out:			; make the text exit the display when the transmission is finished
000905 95a8
000906 e708
000907 2e30
000908 e001
000909 930f
00090a 923f
00090b e300
00090c 2e30
00090d e006
00090e 943a
00090f f7f1
000910 943a
000911 950a
000912 f7d9
000913 903f
000914 910f
000915 943a
000916 f791
000917 950a
000918 f781
000919 2c89
00091a 2c9a
00091b 2cab
00091c 2cbc
00091d 2ccd
00091e 2cde
00091f 2cef
000920 e000
000921 2ef0
000922 dbdd
000923 9190 0105
000925 2399                      	MES_OUTPUT_SPACE
000926 f411                      	brne	PC+3
000927 958a                      	dec		b2
000928 f6e1                      	brne	mes_fade_out
000929 dc79                      	rcall	led_color_shift
00092a cf39                      	rjmp	mes_t_serial_loop
                                 
                                 
                                 ; ============================ DATASEG ==============================
                                 
                                 
                                 .dseg
000103                           b_in :	.byte 1 ; in pointer
000104                           b_out:	.byte 1 ; out pointer
000105                           b_n:	.byte 1 ; nombre d'?l?ments dans le buffer circulaire
000106                           buffer: .byte rx_len
                                 .cseg
                                 
                                 tldr:
00092b 0002
00092c 0000
00092d 0000                      .db 2,   0b00000000, 0b00000000, 0b00000000, 0b00000000, 0b00000000 \ ;  space
00092e 0204
00092f 0959
000930 0006                      .db 4,   0b00000010, 0b01011001, 0b00001001, 0b00000110, 0b00000000 \ ;	 ?
000931 5f01
000932 0000
000933 0000                      .db 1,   0b01011111, 0b00000000, 0b00000000, 0b00000000, 0b00000000 \ ;  !
000934 0301
000935 0000
000936 0000                      .db 1,	 0b00000011, 0b00000000, 0b00000000, 0b00000000, 0b00000000 \ ;  '
000937 3e04
000938 4141
000939 003e                      .db 4,   0b00111110, 0b01000001, 0b01000001, 0b00111110, 0b00000000 \ ;  0
00093a 4203
00093b 407f
00093c 0000                      .db 3,   0b01000010, 0b01111111, 0b01000000, 0b00000000, 0b00000000 \ ;  1
00093d 6204
00093e 4951
00093f 0046                      .db 4,   0b01100010, 0b01010001, 0b01001001, 0b01000110, 0b00000000 \ ;  2
000940 2204
000941 4941
000942 0036                      .db 4,   0b00100010, 0b01000001, 0b01001001, 0b00110110, 0b00000000 \ ;  3
000943 1804
000944 1214
000945 007f                      .db 4,   0b00011000, 0b00010100, 0b00010010, 0b01111111, 0b00000000 \ ;  4
000946 2704
000947 4545
000948 0039                      .db 4,   0b00100111, 0b01000101, 0b01000101, 0b00111001, 0b00000000 \ ;  5
000949 3e04
00094a 4949
00094b 0030                      .db 4,   0b00111110, 0b01001001, 0b01001001, 0b00110000, 0b00000000 \ ;  6
00094c 6104
00094d 0911
00094e 0007                      .db 4,   0b01100001, 0b00010001, 0b00001001, 0b00000111, 0b00000000 \ ;  7
00094f 3604
000950 4949
000951 0036                      .db 4,   0b00110110, 0b01001001, 0b01001001, 0b00110110, 0b00000000 \ ;  8
000952 0604
000953 4949
000954 003e                      .db 4,   0b00000110, 0b01001001, 0b01001001, 0b00111110, 0b00000000 \ ;  9
000955 7e04
000956 1111
000957 007e                      .db 4,   0b01111110, 0b00010001, 0b00010001, 0b01111110, 0b00000000 \ ;  A
000958 7f04
000959 4949
00095a 0036                      .db 4,   0b01111111, 0b01001001, 0b01001001, 0b00110110, 0b00000000 \ ;  B
00095b 3e04
00095c 4141
00095d 0022                      .db 4,   0b00111110, 0b01000001, 0b01000001, 0b00100010, 0b00000000 \ ;  C
00095e 7f04
00095f 4141
000960 003e                      .db 4,   0b01111111, 0b01000001, 0b01000001, 0b00111110, 0b00000000 \ ;  D
000961 7f04
000962 4949
000963 0041                      .db 4,   0b01111111, 0b01001001, 0b01001001, 0b01000001, 0b00000000 \ ;  E
000964 7f04
000965 0909
000966 0001                      .db 4,   0b01111111, 0b00001001, 0b00001001, 0b00000001, 0b00000000 \ ;  F
000967 3e04
000968 4941
000969 007a                      .db 4,   0b00111110, 0b01000001, 0b01001001, 0b01111010, 0b00000000 \ ;  G
00096a 7f04
00096b 0808
00096c 007f                      .db 4,   0b01111111, 0b00001000, 0b00001000, 0b01111111, 0b00000000 \ ;  H
00096d 4103
00096e 417f
00096f 0000                      .db 3,   0b01000001, 0b01111111, 0b01000001, 0b00000000, 0b00000000 \ ;  I
000970 3004
000971 4140
000972 003f                      .db 4,   0b00110000, 0b01000000, 0b01000001, 0b00111111, 0b00000000 \ ;  J
000973 7f04
000974 1408
000975 0063                      .db 4,   0b01111111, 0b00001000, 0b00010100, 0b01100011, 0b00000000 \ ;  K
000976 7f04
000977 4040
000978 0040                      .db 4,   0b01111111, 0b01000000, 0b01000000, 0b01000000, 0b00000000 \ ;  L
000979 7f05
00097a 0c02
00097b 7f02                      .db 5,   0b01111111, 0b00000010, 0b00001100, 0b00000010, 0b01111111 \ ;  M
00097c 7f05
00097d 0804
00097e 7f10                      .db 5,   0b01111111, 0b00000100, 0b00001000, 0b00010000, 0b01111111 \ ;  N
00097f 3e04
000980 4141
000981 003e                      .db 4,   0b00111110, 0b01000001, 0b01000001, 0b00111110, 0b00000000 \ ;  O
000982 7f04
000983 0909
000984 0006                      .db 4,   0b01111111, 0b00001001, 0b00001001, 0b00000110, 0b00000000 \ ;  P
000985 3e04
000986 4141
000987 00be                      .db 4,   0b00111110, 0b01000001, 0b01000001, 0b10111110, 0b00000000 \ ;  Q
000988 7f04
000989 0909
00098a 0076                      .db 4,   0b01111111, 0b00001001, 0b00001001, 0b01110110, 0b00000000 \ ;  R
00098b 4604
00098c 4949
00098d 0032                      .db 4,   0b01000110, 0b01001001, 0b01001001, 0b00110010, 0b00000000 \ ;  S
00098e 0105
00098f 7f01
000990 0101                      .db 5,   0b00000001, 0b00000001, 0b01111111, 0b00000001, 0b00000001 \ ;  T
000991 3f04
000992 4040
000993 003f                      .db 4,   0b00111111, 0b01000000, 0b01000000, 0b00111111, 0b00000000 \ ;  U
000994 0f05
000995 4030
000996 0f30                      .db 5,   0b00001111, 0b00110000, 0b01000000, 0b00110000, 0b00001111 \ ;  V
000997 3f05
000998 3840
000999 3f40                      .db 5,   0b00111111, 0b01000000, 0b00111000, 0b01000000, 0b00111111 \ ;  W
00099a 6305
00099b 0814
00099c 6314                      .db 5,   0b01100011, 0b00010100, 0b00001000, 0b00010100, 0b01100011 \ ;  X
00099d 0705
00099e 7008
00099f 0708                      .db 5,   0b00000111, 0b00001000, 0b01110000, 0b00001000, 0b00000111 \ ;  Y
0009a0 6104
0009a1 4951
0009a2 0047                      .db 4,   0b01100001, 0b01010001, 0b01001001, 0b01000111, 0b00000000	\ ;  Z
                                 tldr_min:
0009a3 2004
0009a4 5454
0009a5 0078                      .db 4, 	 0b00100000, 0b01010100, 0b01010100, 0b01111000, 0b00000000 \ ; a
0009a6 7f04
0009a7 4444
0009a8 0038                      .db 4, 	 0b01111111, 0b01000100, 0b01000100, 0b00111000, 0b00000000 \ ; b
0009a9 3804
0009aa 4444
0009ab 0028                      .db 4, 	 0b00111000, 0b01000100, 0b01000100, 0b00101000, 0b00000000 \ ; c
0009ac 3804
0009ad 4444
0009ae 007f                      .db 4,   0b00111000, 0b01000100, 0b01000100, 0b01111111, 0b00000000 \ ; d
0009af 3804
0009b0 5454
0009b1 0018                      .db 4, 	 0b00111000, 0b01010100, 0b01010100, 0b00011000, 0b00000000 \ ; e
0009b2 0403
0009b3 057e
0009b4 0000                      .db 3, 	 0b00000100, 0b01111110, 0b00000101, 0b00000000, 0b00000000 \ ; f
0009b5 9804
0009b6 a4a4
0009b7 0078                      .db 4, 	 0b10011000, 0b10100100, 0b10100100, 0b01111000, 0b00000000 \ ; g
0009b8 7f04
0009b9 0404
0009ba 0078                      .db 4, 	 0b01111111, 0b00000100, 0b00000100, 0b01111000, 0b00000000 \ ; h
0009bb 4403
0009bc 407d
0009bd 0000                      .db 3, 	 0b01000100, 0b01111101, 0b01000000, 0b00000000, 0b00000000 \ ; i
0009be 4004
0009bf 8480
0009c0 007d                      .db 4, 	 0b01000000, 0b10000000, 0b10000100, 0b01111101, 0b00000000 \ ; j
0009c1 7f04
0009c2 2810
0009c3 0044                      .db 4,	 0b01111111, 0b00010000, 0b00101000, 0b01000100, 0b00000000 \ ; k
0009c4 4103
0009c5 407f
0009c6 0000                      .db 3, 	 0b01000001, 0b01111111, 0b01000000, 0b00000000, 0b00000000 \ ; l
0009c7 7c05
0009c8 7c04
0009c9 7804                      .db 5, 	 0b01111100, 0b00000100, 0b01111100, 0b00000100, 0b01111000 \ ; m
0009ca 7c04
0009cb 0404
0009cc 0078                      .db 4, 	 0b01111100, 0b00000100, 0b00000100, 0b01111000, 0b00000000 \ ; n
0009cd 3804
0009ce 4444
0009cf 0038                      .db 4, 	 0b00111000, 0b01000100, 0b01000100, 0b00111000, 0b00000000 \ ; o
0009d0 fc04
0009d1 2424
0009d2 0018                      .db 4, 	 0b11111100, 0b00100100, 0b00100100, 0b00011000, 0b00000000 \ ; p
0009d3 1804
0009d4 2424
0009d5 00fc                      .db 4, 	 0b00011000, 0b00100100, 0b00100100, 0b11111100, 0b00000000 \ ; q
0009d6 7c04
0009d7 0408
0009d8 0004                      .db 4, 	 0b01111100, 0b00001000, 0b00000100, 0b00000100, 0b00000000 \ ; r
0009d9 4804
0009da 5454
0009db 0024                      .db 4,	 0b01001000, 0b01010100, 0b01010100, 0b00100100, 0b00000000 \ ; s
0009dc 0403
0009dd 443f
0009de 0000                      .db 3, 	 0b00000100, 0b00111111, 0b01000100, 0b00000000, 0b00000000 \ ; t
0009df 3c04
0009e0 4040
0009e1 007c                      .db 4, 	 0b00111100, 0b01000000, 0b01000000, 0b01111100, 0b00000000 \ ; u
0009e2 1c05
0009e3 4020
0009e4 1c20                      .db 5, 	 0b00011100, 0b00100000, 0b01000000, 0b00100000, 0b00011100 \ ; v
0009e5 3c05
0009e6 3c40
0009e7 3c40                      .db 5, 	 0b00111100, 0b01000000, 0b00111100, 0b01000000, 0b00111100 \ ; w
0009e8 4405
0009e9 1028
0009ea 4428                      .db 5, 	 0b01000100, 0b00101000, 0b00010000, 0b00101000, 0b01000100 \ ; x
0009eb 9c04
0009ec a0a0
0009ed 007c                      .db 4, 	 0b10011100, 0b10100000, 0b10100000, 0b01111100, 0b00000000 \ ; y
0009ee 6403
0009ef 4c54
0009f0 0000                      .db 3, 	 0b01100100, 0b01010100, 0b01001100, 0b00000000, 0b00000000 \ ; z
                                 
                                 ; ------------------------------------------------------------------------------------------
                                 
                                 animation:
0009f1 ef0f
0009f2 bf0d
0009f3 e100
0009f4 bf0e                      		LDSP	RAMEND		; Branch here w/ rcall but infinite loop => no ret => no use for all the prior infos on the stack
0009f5 dbe2                      		rcall	mode_anim	;												   => free memory to avoid eventual saturation
                                 
                                 ; ------------------------------------------------------------------------------------------
                                 
                                 jeu:
0009f6 ef0f
0009f7 bf0d
0009f8 e100
0009f9 bf0e                      		LDSP	RAMEND
0009fa dcc0                      		rcall	mode_jeu
                                 	
                                 ; ------------------------------------------------------------------------------------------
                                 
                                 spectro:
0009fb ef0f
0009fc bf0d
0009fd e100
0009fe bf0e                      		LDSP	RAMEND
0009ff ddd3                      		rcall	mode_spectro
                                 
                                 ; ------------------------------------------------------------------------------------------
                                 
                                 message:
000a00 ef0f
000a01 bf0d
000a02 e100
000a03 bf0e                      		LDSP	RAMEND	
000a04 de46                      		rcall	mode_message
                                 
                                 ; ------------------------------------------------------------------------------------------


RESOURCE USE INFORMATION
------------------------

Notice:
The register and instruction counts are symbol table hit counts,
and hence implicitly used resources are not counted, eg, the
'lpm' instruction without operands implicitly uses r0 and z,
none of which are counted.

x,y,z are separate entities in the symbol table and are
counted separately from r26..r31 here.

.dseg memory usage only counts static data declared with .byte

"ATmega128" register use summary:
x  :   6 y  :   0 z  :   7 r0 :  91 r1 :   0 r2 :  76 r3 :  74 r4 :  71 
r5 :  69 r6 :   0 r7 :   0 r8 :  20 r9 :  27 r10:  27 r11:  28 r12:  33 
r13:  22 r14:  22 r15:  22 r16: 653 r17: 135 r18:  58 r19:  54 r20:  32 
r21:  49 r22:  15 r23:  30 r24:  11 r25:  25 r26:   3 r27:   3 r28:   4 
r29:   0 r30:  66 r31:  30 
Registers used: 30 out of 35 (85.7%)

"ATmega128" instruction use summary:
.lds  :   0 .sts  :   0 adc   :   0 add   :  13 adiw  :  28 and   :   0 
andi  :  27 asr   :   2 bclr  :   0 bld   :   0 brbc  :   0 brbs  :   0 
brcc  :  17 brcs  :  32 break :   0 breq  :  68 brge  :   3 brhc  :   0 
brhs  :   0 brid  :   0 brie  :   0 brlo  :  10 brlt  :   3 brmi  :   1 
brne  :  81 brpl  :   1 brsh  :  11 brtc  :   5 brts  :   1 brvc  :   0 
brvs  :   0 bset  :   0 bst   :   1 call  :   0 cbi   :   3 cbr   :   0 
clc   :   1 clh   :   0 cli   :   4 cln   :   0 clr   :  30 cls   :   0 
clt   :   5 clv   :   0 clz   :   0 com   :  27 cp    :   4 cpc   :   3 
cpi   :  48 cpse  :   0 dec   : 108 elpm  :   0 eor   :   0 fmul  :   0 
fmuls :   0 fmulsu:   0 icall :   1 ijmp  :   1 in    :   8 inc   :  10 
jmp   :  10 ld    :   9 ldd   :   0 ldi   : 343 lds   :  21 lpm   :  85 
lsl   :  63 lsr   :  13 mov   : 234 movw  :   4 mul   :   4 muls  :   0 
mulsu :   0 neg   :   0 nop   :  99 or    :   0 ori   :   3 out   : 118 
pop   :  97 push  :  96 rcall :  95 ret   :  30 reti  :   1 rjmp  : 121 
rol   :  12 ror   :  13 sbc   :   5 sbci  :   0 sbi   :   6 sbic  :   0 
sbis  :   1 sbiw  :   0 sbr   :   1 sbrc  :  17 sbrs  :   7 sec   :   0 
seh   :   0 sei   :   9 sen   :   0 ser   :   1 ses   :   0 set   :   3 
sev   :   0 sez   :   0 sleep :   0 spm   :   0 st    :   1 std   :   0 
sts   :  24 sub   :   5 subi  :  19 swap  :   4 tst   :  52 wdr   :  14 

Instructions used: 68 out of 114 (59.6%)

"ATmega128" memory use summary [bytes]:
Segment   Begin    End      Code   Data   Used    Size   Use%
---------------------------------------------------------------
[.cseg] 0x000000 0x00140a   4394    680   5074  131072   3.9%
[.dseg] 0x000100 0x000146      0     70     70    4096   1.7%
[.eseg] 0x000000 0x000000      0      0      0    4096   0.0%

Assembly complete, 0 errors, 0 warnings
